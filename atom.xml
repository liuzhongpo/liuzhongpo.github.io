<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LZP BLOG</title>
  
  <subtitle>信念和目标，永远洋溢在内心...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liuzhongpo.github.io/"/>
  <updated>2019-02-17T03:22:19.602Z</updated>
  <id>https://liuzhongpo.github.io/</id>
  
  <author>
    <name>lzp</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【技术杂技】Lombok</title>
    <link href="https://liuzhongpo.github.io/2018/11/12/%E3%80%90%E6%8A%80%E6%9C%AF%E6%9D%82%E6%8A%80%E3%80%91lombok/"/>
    <id>https://liuzhongpo.github.io/2018/11/12/【技术杂技】lombok/</id>
    <published>2018-11-11T16:00:00.000Z</published>
    <updated>2019-02-17T03:22:19.602Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际开发中，大家都应该会碰到一个场景：定义大量的entity，然后通过Eclipse或者IDEA去生成其属性的构造器、getter、setter、equals、hashcode、toString方法；当要对某个属性进行改变时，都需要重新生成这些方法，那Java中有没有一种方式能够解决这个问题呢？答案是有，就是lombok。</p><h1 id="Lombok简介"><a href="#Lombok简介" class="headerlink" title="Lombok简介"></a>Lombok简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p><blockquote><p>官方地址：<a href="https://projectlombok.org/" target="_blank" rel="noopener">https://projectlombok.org/</a><br>github地址：<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener">https://github.com/rzwitserloot/lombok</a></p></blockquote><h1 id="Lombok安装（IDEA）"><a href="#Lombok安装（IDEA）" class="headerlink" title="Lombok安装（IDEA）"></a>Lombok安装（IDEA）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Settings -&gt; Plugins -&gt; Browse repositories<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="http://s1.wailian.download/2017/11/12/image.png" alt="image.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等安装完，重启一下。因为我常用IDEA，至于Eclipse安装lombok插件，请自行百度一下。</p><h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</div><div class="line">    &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h1 id="常用注解介绍"><a href="#常用注解介绍" class="headerlink" title="常用注解介绍"></a>常用注解介绍</h1><h2 id="Getter-Setter-Accessors"><a href="#Getter-Setter-Accessors" class="headerlink" title="Getter Setter Accessors"></a>Getter Setter Accessors</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@Getter @Setter</code>修饰任何字段，让lombok自动生成默认的getter / setter方法，默认生成的方法是public的。如果要修改方法修饰符可以设置AccessLevel的值，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div></pre></td></tr></table></figure></p><p><code>@Accessors</code> 主要用于控制生成的getter和setter,主要参数介绍：</p><ul><li>fluent boolean值，默认为false。此字段主要为控制生成的getter和setter方法前面是否带get/set</li><li>chain boolean值，默认false。如果设置为true，setter返回的是此对象，方便链式调用方法</li><li>prefix 设置前缀 例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Accessors</span>(prefix = <span class="string">"abc"</span>) <span class="keyword">private</span> String abcAge ;</div><div class="line"><span class="comment">//当生成get/set方法时，会把此前缀去掉</span></div></pre></td></tr></table></figure></li></ul><h2 id="构造器相关"><a href="#构造器相关" class="headerlink" title="构造器相关"></a>构造器相关</h2><ul><li><code>@NoArgsConstructor</code> 生成一个无参构造方法。当类中有final字段没有被初始化时，编译器会报错，此时可用<code>@NoArgsConstructor(force = true)</code>，然后就会为没有初始化的final字段设置默认值 0 / false / null。对于具有约束的字段（例如<code>@NonNull</code>字段），不会生成检查或分配，因此请注意，正确初始化这些字段之前，这些约束无效。</li><li><p><code>@RequiredArgsConstructor</code> 会生成构造方法（可能带参数也可能不带参数），如果带参数，这参数只能是以final修饰的未经初始化的字段，或者是以<code>@NonNull</code>注解的未经初始化的字段.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiredArgsConstructor</span>(staticName = <span class="string">"of"</span>)</div><div class="line"><span class="comment">// 会生成一个of()的静态方法，并把构造方法设置为私有的</span></div></pre></td></tr></table></figure></li><li><p><code>@AllArgsConstructor</code> 生成一个全参数的构造方法</p></li></ul><h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ToString</code>生成toString()方法，默认情况下，会按顺序 （以逗号分隔）打印你的类名称以及每个字段，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">User(id=<span class="keyword">null</span>, name=<span class="keyword">null</span>, age=<span class="keyword">null</span>)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样设置不包含哪些字段，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ToString</span>(exclude = <span class="string">"id"</span>) </div><div class="line"><span class="meta">@ToString</span>(exclude = &#123;<span class="string">"id"</span>,<span class="string">"name"</span>&#125;)</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果继承的有父类的话，可以设置callSuper 让其调用父类的toString()方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ToString</span>(callSuper = <span class="keyword">true</span>)</div></pre></td></tr></table></figure></p><h2 id="Equals-amp-HashCode"><a href="#Equals-amp-HashCode" class="headerlink" title="Equals&amp;HashCode"></a>Equals&amp;HashCode</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@EqualsAndHashCode</code>，生成hashCode()和equals()方法，默认情况下，它将使用所有非静态，非transient字段。但可以通过在可选的exclude参数中来排除更多字段。或者，通过在parameter参数中命名它们来准确指定希望使用哪些字段。</p><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@Data</code>包含了<code>@ToString</code>，<code>@EqualsAndHashCode</code>，<code>@Getter</code> / <code>@Setter</code>和<code>@RequiredArgsConstructor</code>的功能</p><h2 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h2><p><code>@Synchronized</code>：给方法加上同步锁<br><code>@Wither</code> ：提供了给final字段赋值的一种方法<br><code>@onX</code> ： 在注解里面添加注解的方式<br><code>@Builder</code>：为你的类生成复杂的构建器API。<br><code>@Delegate</code>：这个注解也是相当的牛逼，它会该类生成一些列的方法，这些方法都来自与List接口<br><code>@Log4j</code> ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他注解，查询官方文档。</p><h1 id="Lombok问题"><a href="#Lombok问题" class="headerlink" title="Lombok问题"></a>Lombok问题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lombok 很强大，是生产力神器，语法设计合理易用，当然也很邪恶。从原理上来说，Lombok的魔法就在于其修改了AST(抽象语法树)，分析和生成class阶段使用了修改后的AST，也就最终改变了生成的字节码文件。所以说，它甚至在某种程度上重新定义了 Java 本身的语法（写法），而这种“非官方”的重定义是不是会带来一系列问题也未可知，只能实践求证。以下是我开发中碰到的一些问题：</p><ul><li>无法支持多种参数构造器的重载</li><li>大大降低了源代码文件的可读性和完整性，降低了阅读源代码的舒适度</li><li>代码易手时带来的注解冲突、Java新手的掌握成本等等一系列问题</li><li>奇淫巧技，使用会有争议</li></ul>]]></content>
    
    <summary type="html">
    
      逛开源社区的时候无意发现的一个非常好用的小工具，在新产品开发中用了一段时间，觉得还可以，特此推荐一下。
    
    </summary>
    
      <category term="技术杂技" scheme="https://liuzhongpo.github.io/categories/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%8A%80/"/>
    
    
      <category term="技术杂技" scheme="https://liuzhongpo.github.io/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E6%8A%80/"/>
    
      <category term="tool" scheme="https://liuzhongpo.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://liuzhongpo.github.io/2018/10/24/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://liuzhongpo.github.io/2018/10/24/volatile关键字/</id>
    <published>2018-10-23T16:00:00.000Z</published>
    <updated>2018-10-24T12:49:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile关键字，在Java5之前是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java5之后，volatile关键字重获生机。volatile关键字是与Java内存模型有关的，要对内存模型和并发编程的概念有一定的了解，所以，在使用方面不是一件容易的事情。同时，此文大部分参考了这位大神的<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">volatile关键字解析</a>。</p><h2 id="并发编程的三个概念"><a href="#并发编程的三个概念" class="headerlink" title="并发编程的三个概念"></a>并发编程的三个概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在并发编程中，我们通常会遇到以下三个问题：原子性问题、可见性问题、有序性问题。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</li><li>一个很经典的例子就是银行账户转账问题：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。同样地反映到并发编程中会出现什么结果呢？举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i = <span class="number">9</span>;</div></pre></td></tr></table></figure></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><ul><li>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</li><li>举个简单的例子，看下面这段代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1执行的代码</span></div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">i = <span class="number">10</span>;</div><div class="line"> </div><div class="line"><span class="comment">//线程2执行的代码</span></div><div class="line">j = i;</div></pre></td></tr></table></figure></li></ul><p>　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。<br>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><ul><li>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </div><div class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></div><div class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></div></pre></td></tr></table></figure></li></ul><p>　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生<strong>指令重排序（Instruction Reorder）</strong>。<br>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。<br>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。<br>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></div><div class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></div><div class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></div><div class="line">r = a*a;     <span class="comment">//语句4</span></div></pre></td></tr></table></figure></p><p>　　这段代码有4个语句，那么可能的一个执行顺序是：<br><img src="http://s1.wailian.download/2017/10/28/image.png" alt="image.png"></p><p>　　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3<br>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。<br>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p><p>　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。<br> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。<br>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java内存模型规定所有的变量都是存在主存当中（类似于CPU的物理内存），<strong>每个线程都有自己的工作内存</strong>（类似于cpu的高速缓存,有兴趣的朋友可以阅读<a href="http://blog.jobbole.com/36263/" target="_blank" rel="noopener"> CPU 高速缓存 </a>这篇博文）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个简单的例子：在java中，执行下面这个语句：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">i  = <span class="number">10</span>;</div></pre></td></tr></table></figure></p><p>　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p><h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。<br>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：<br>　　请分析以下哪些操作是原子性操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x = <span class="number">10</span>;         <span class="comment">//语句1</span></div><div class="line">y = x;         <span class="comment">//语句2</span></div><div class="line">x++;           <span class="comment">//语句3</span></div><div class="line">x = x + <span class="number">1</span>;     <span class="comment">//语句4</span></div></pre></td></tr></table></figure></p><p>　　初看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。<br>语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。<br> 　　所以上面4个语句只有语句1的操作具备原子性。<br>　　也就是说，<strong>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作</strong>。<br>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。<br>　　从上面可以看出，<strong>Java内存模型只保证了基本读取和赋值是原子性操作</strong>，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="可见性-1"><a href="#可见性-1" class="headerlink" title="可见性"></a>可见性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于可见性，Java提供了volatile关键字来保证可见性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面就来具体介绍下happens-before原则（先行发生原则）：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.    程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.    锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.    volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.    传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.    线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.    线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.    线程终结规则：线程中所有的操作都先行发生于线程的终止检测，通过Thread.join()方法结束,Thread.isAlive()的返回值手段检测到线程已经终止执行。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.    对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这8条原则摘自《深入理解Java虚拟机》。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们来解释一下前4条规则：<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第四条规则实际上就是体现happens-before原则具备传递性。</p><h2 id="剖析volatile关键字"><a href="#剖析volatile关键字" class="headerlink" title="剖析volatile关键字"></a>剖析volatile关键字</h2><h3 id="volatile两层语义"><a href="#volatile两层语义" class="headerlink" title="volatile两层语义"></a>volatile两层语义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）禁止进行指令重排序。</strong><br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先看一段代码，假如线程1先执行，线程2后执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1</span></div><div class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">while</span>(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//线程2</span></div><div class="line">stop = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p><p>　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。<br>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。<br>　　但是用volatile修饰之后就变得不一样了：<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一：使用volatile关键字会强制将修改的值立即写入主存；<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。<br>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。那么线程1读取到的就是最新的正确的值。</p><h3 id="能保证原子性吗？"><a href="#能保证原子性吗？" class="headerlink" title="能保证原子性吗？"></a>能保证原子性吗？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能有的朋友就会有疑问，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是10000。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面已经提到过，<strong>自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存</strong>。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如某个时刻变量inc的值为10，线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。那么两个线程分别进行了一次自增操作后，inc只增加了1。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能这里又会有疑问：前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把上面的代码改成以下任何一种都可以达到效果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.    Synchronized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.    Lock<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.    Atomic体系的类（只保证本身方法的原子性），并不保证多次操作的原子性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。<strong>atomic是利用CAS来实现原子性操作的（Compare And Swap）</strong>，CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p><h3 id="能保证有序性吗？"><a href="#能保证有序性吗？" class="headerlink" title="能保证有序性吗？"></a>能保证有序性吗？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile关键字禁止指令重排序有两层意思：<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>　　可能上面说的比较绕，举个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//x、y为非volatile变量</span></div><div class="line"><span class="comment">//flag为volatile变量</span></div><div class="line"> </div><div class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></div><div class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></div><div class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></div><div class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></div><div class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></div></pre></td></tr></table></figure></p><p>　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。<br>　　那么我们回到前面举的一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程1:</span></div><div class="line">context = loadContext();   <span class="comment">//语句1</span></div><div class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></div><div class="line"> </div><div class="line"><span class="comment">//线程2:</span></div><div class="line"><span class="keyword">while</span>(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p><p>　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><h3 id="原理和实现机制"><a href="#原理和实现机制" class="headerlink" title="原理和实现机制"></a>原理和实现机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面这段话摘自《深入理解Java虚拟机》：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”<br>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）它会强制将对缓存的修改操作立即写入主存；<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2017/10/28/imaged71ca.png" alt="imaged71ca.png"></p><h3 id="volatile使用场景"><a href="#volatile使用场景" class="headerlink" title="volatile使用场景"></a>volatile使用场景</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1）对变量的写操作不依赖于当前值<br>　　&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2）该变量没有包含在具有其他变量的不变式中<br>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>场景</strong>：状态标记量和double check</p>]]></content>
    
    <summary type="html">
    
      经常在很多框架底层看到此关键字，一直不明白其含义，通过这次来学习volatile。
    
    </summary>
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="volatile" scheme="https://liuzhongpo.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】Redis Replication（主从复制）</title>
    <link href="https://liuzhongpo.github.io/2018/07/29/%E3%80%90Redis%E3%80%91Redis%20Replication%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89/"/>
    <id>https://liuzhongpo.github.io/2018/07/29/【Redis】Redis Replication（主从复制）/</id>
    <published>2018-07-28T16:00:00.000Z</published>
    <updated>2018-07-29T09:18:23.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主从搭建-1主2从"><a href="#主从搭建-1主2从" class="headerlink" title="主从搭建(1主2从)"></a>主从搭建(1主2从)</h1><ul><li>3台redis实例，ip和redis端口：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">192.168.1.15:6379</div><div class="line">192.168.1.16:6379</div><div class="line">192.168.1.17:6379</div></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;准备把<code>192.168.1.15</code>作为主，<code>192.168.1.16</code>、<code>192.168.1.17</code>作为从。</p><ul><li>丛机相关配置修改(6379.conf,原redis.conf)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span> 192.168.1.16 <span class="comment"># 192.168.1.17,绑定本机ip</span></div><div class="line">slaveof 192.168.1.15 6379 <span class="comment"># slaveof  master主机ip 端口号</span></div><div class="line">slave-read-only yes <span class="comment"># 默认就是yes，开启了只读的redis slave node，会拒绝所有的写操作，强制读写分离</span></div></pre></td></tr></table></figure><ul><li>主机相关配置修改(6379.conf,原redis.conf)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span> 192.168.1.15</div><div class="line">slave-read-only yes</div></pre></td></tr></table></figure><ul><li>重启3台redis实例，redis相关查看命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli -h ipaddr   <span class="comment">#登录指定ip的redis</span></div><div class="line">info replication  <span class="comment">#查看redis相关信息</span></div></pre></td></tr></table></figure><h1 id="replication流程"><a href="#replication流程" class="headerlink" title="replication流程"></a>replication流程</h1><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><pre><code>1. slave node启动，仅仅保存master node的信息，包括master node的host和ip，但是复制流程没开始。(master host和ip来源根据redis.conf里面的slaveof配置的)。2. slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接。3. slave node发送ping命令给master node。4. 口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证。5. slave发送PSYNC命令给master，开始数据同步6. master node第一次执行**全量复制(full resynchronization)**，将所有数据发给slave node。7. slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据(**增量复制**)</code></pre><ul><li>注意事项：<ol><li>slave node做复制的时候，是不会block master node的正常工作的。</li><li>slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务;但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了。</li><li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。</li><li>过期key处理：slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</li><li>全量复制和增量复制，具体还需要根据master run id、backlog、offset来判断是全量还是增量，这几个参数相关解释如下。  </li></ol></li></ul><h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><ol><li>master执行<strong>bgsave</strong>，在本地生成一份rdb快照文件。</li><li>master node将rdb快照文件发送给salve node，如果rdb复制时间超过60秒（repl-timeout），那么slave node就会认为复制失败，适当调大这个参数(对于千兆网卡的机器，一般每秒传输100MB，6G文件，很可能超过60s)。</li><li>master node在生成rdb时，会将所有新的写命令缓存在内存中，在salve node保存了rdb之后，再将新的写命令复制给salve node。</li><li><code>client-output-buffer-limit slave 256MB 64MB 60</code> ，如果在复制期间，内存缓冲区持续60s消耗超过64MB，或者一次性超过256MB，那么停止复制，断开复制连接，复制失败。</li><li>slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中，同时基于薪的数据版本对外提供服务。</li><li>如果slave node开启了AOF，那么会立即执行<strong>BGREWRITEAOF</strong>，重写AOF。</li></ol><ul><li>注意事项：<ol><li>rdb生成、rdb通过网络拷贝、slave旧数据的清理、slave aof rewrite，很耗费时间。如果复制的数据量在4G~6G之间，那么可能全量复制时间消耗到1分半到2分钟(理论测试值,具体看机器配置以及网络配置)</li><li>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘保存。</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">repl-diskless-sync no <span class="comment">#默认no</span></div><div class="line">repl-diskless-sync-delay <span class="comment">#等待一定时长再开始复制，因为要等更多slave重新连接过来</span></div></pre></td></tr></table></figure><h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><ol><li>如果全量复制过程中，master-slave网络连接断掉，那么salve重新连接master时，会触发增量复制。</li><li>master直接从自己的backlog中获取部分丢失的数据，发送给slave node，默认backlog就是1MB。</li><li>msater就是根据slave发送的psync中的offset来从backlog中获取数据的。</li></ol><h2 id="相关参数详解"><a href="#相关参数详解" class="headerlink" title="相关参数详解"></a>相关参数详解</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><ul><li>master和slave都会维护一个offset，保存在backlog中。</li><li>master会在自身不断累加offset，slave也会在自身不断累加offset。</li><li>slave每秒都会上报自己的offset给master，同时master也会保存每个slave的offset。</li><li>这并不是说特定就用在全量复制的，主要是master和slave都要知道各自的数据的offset，才能知道互相之间的数据不一致的情况。</li></ul><h3 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a>backlog</h3><ul><li>master node有一个backlog，默认是1MB大小。</li><li>master node给slave node复制数据时，也会将数据在backlog中同步写一份。</li><li>backlog主要是用来做全量复制中断时候的增量复制的。</li></ul><h3 id="master-run-id"><a href="#master-run-id" class="headerlink" title="master run id"></a>master run id</h3><ul><li><code>info server</code>，可以看到master run id。</li><li>如果根据host+ip定位master node是不靠谱，，如果master node重启或者数据出现了变化，那么slave node应该根据不同的run id区分，run id不同就做全量复制。</li><li>如果需要不更改run id重启redis，可以使用<code>redis-cli debug reload</code>命令。</li></ul><h3 id="psync"><a href="#psync" class="headerlink" title="psync"></a>psync</h3><ul><li>从节点使用psync从master node进行复制，psync runid offset。</li><li>master node会根据自身的情况返回响应信息，可能是FULLRESYNC runid，offset触发全量复制，可能是CONTINUE触发增量复制。</li></ul><h3 id="hearbeat和异步复制"><a href="#hearbeat和异步复制" class="headerlink" title="hearbeat和异步复制"></a>hearbeat和异步复制</h3><ul><li>Hearbeat：主从节点互相都会发送heartbeat信息，master默认每隔10秒发送一次heartbeat，salve node每隔1秒发送一个heartbeat。</li><li>异步复制：master每次接收到写命令之后，现在内部写入数据，然后异步发送给slave node。(redis 2.8开始，slave node会周期性地确认自己每次复制的数据量)</li></ul><h1 id="master持久化"><a href="#master持久化" class="headerlink" title="master持久化"></a>master持久化</h1><ul><li>采用了主从架构，那么建议必须开启master node的持久化！不建议用slave node作为master node的数据热备。<br>因为如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了<ul><li>master -&gt; RDB和AOF都关闭了 -&gt; 全部在内存中。</li><li>master宕机，重启，是没有本地数据可以恢复的，然后就会直接认为自己的数据是空的。</li><li>master就会将空的数据集同步到slave上去，所有slave的数据全部清空。100%的数据丢失。</li></ul></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，master节点，必须要使用持久化机制。</p><ul><li>master的各种备份方案也需要做，如果万一本地的所有文件丢失了，从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的。<ul><li>注意：slave node可以自动接管master node，但是也可能sentinal还没有检测到master failure，master node就自动重启了，还是可能导致上面的所有slave node数据清空故障。</li></ul></li></ul><h1 id="redis-replication-高可用"><a href="#redis-replication-高可用" class="headerlink" title="redis replication 高可用"></a>redis replication 高可用</h1><ul><li>redis高可用架构，叫做故障转移 failover，也可以叫做主备切换。<ul><li>一旦master故障，在很短时间内，就会切换到另外一个master上去，可能redis就几分钟或者几秒钟不可用。</li></ul></li><li>当然这是，<strong>redis replication基于哨兵sentinal的高可用性</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      搭建redis replication，以及明白其流程和相关配置。
    
    </summary>
    
      <category term="redis" scheme="https://liuzhongpo.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://liuzhongpo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】生产环境启动方案</title>
    <link href="https://liuzhongpo.github.io/2018/01/31/%E3%80%90Redis%E3%80%91%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%90%AF%E5%8A%A8%E6%96%B9%E6%A1%88/"/>
    <id>https://liuzhongpo.github.io/2018/01/31/【Redis】生产环境启动方案/</id>
    <published>2018-01-30T16:00:00.000Z</published>
    <updated>2018-01-31T06:14:16.851Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一般的学习，随便用<code>redis-server</code>启动一下redis，做一些实验，这样的话，没什么意义。要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动<br>配置步骤：<br>（1）redis <code>utils</code>目录下，有个<code>redis_init_script</code>脚本<br>（2）将<code>redis_init_script</code>脚本拷贝到linux的<code>/etc/init.d</code>目录中，将<code>redis_init_script</code>重命名为<code>redis_6379</code>，6379是我们希望这个redis实例监听的端口号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp redis_init_script /etc/init.d</div><div class="line">cd /etc/init.d</div><div class="line">mv redis_init_script redis_6379</div></pre></td></tr></table></figure></p><p>（3）修改<code>redis_6379</code>脚本的第6行的<code>REDISPORT</code>，设置为相同的端口号（默认就是6379）<br>（4）创建两个目录：<code>/etc/redis</code>（存放redis的配置文件），<code>/var/redis/6379</code>（存放redis的持久化文件）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir /etc/redis</div><div class="line">mkdir -p /var/redis/6379</div></pre></td></tr></table></figure></p><p>（5）修改redis配置文件（默认在根目录下，<code>redis.conf</code>），拷贝到<code>/etc/redis</code>目录中，修改名称为<code>6379.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp redis.conf /etc/redis</div><div class="line">mv redis.conf 6379.conf</div></pre></td></tr></table></figure></p><p>（6）修改<code>redis.conf</code>中的部分配置为生产环境:</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:center">值</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:left">daemonize</td><td style="text-align:center">yes</td><td style="text-align:center">让redis以daemon进程运行</td></tr><tr><td style="text-align:left">pidfile</td><td style="text-align:center">/var/run/redis_6379.pid</td><td style="text-align:center">设置redis的pid文件位置</td></tr><tr><td style="text-align:left">port</td><td style="text-align:center">6379(默认值)</td><td style="text-align:center">设置redis的监听端口号</td></tr><tr><td style="text-align:left">dir</td><td style="text-align:center">/var/redis/6379</td><td style="text-align:center">设置持久化文件的存储位置</td></tr></tbody></table><p>（7）启动redis，执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /etc/init.d</div><div class="line">chmod 777 redis_6379</div><div class="line">./redis_6379 start</div></pre></td></tr></table></figure></p><p>（8）确认redis进程是否启动，<code>ps -ef | grep redis</code><br>（9）让redis跟随系统启动自动启动,在<code>redis_6379</code>脚本中，最上面，加入两行注释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># chkconfig:   2345 90 10</div><div class="line"># description:  Redis is a persistent key-value database</div></pre></td></tr></table></figure></p><p>（10）执行：<code>chkconfig redis_6379 on</code></p>]]></content>
    
    <summary type="html">
    
      如果一般的学习，随便用redis-server启动一下redis，做一些实验。这样的话，没什么意义。要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动。
    
    </summary>
    
      <category term="redis" scheme="https://liuzhongpo.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://liuzhongpo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>【Redis】安装单机版Redis</title>
    <link href="https://liuzhongpo.github.io/2018/01/31/%E3%80%90Redis%E3%80%91%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Redis/"/>
    <id>https://liuzhongpo.github.io/2018/01/31/【Redis】安装单机版Redis/</id>
    <published>2018-01-30T16:00:00.000Z</published>
    <updated>2018-03-17T13:29:45.478Z</updated>
    
    <content type="html"><![CDATA[<p>官网下载redis安装包，这里使用：<code>redis-3.2.8.tar.gz</code>。安装在<strong>/usr/local</strong>下。</p><h1 id="安装-tcl"><a href="#安装-tcl" class="headerlink" title="安装 tcl"></a>安装 tcl</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</div><div class="line">tar -xzvf tcl8.6.1-src.tar.gz</div><div class="line">cd  /usr/local/tcl8.6.1/unix/</div><div class="line">./configure  </div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar -zxvf redis-3.2.8.tar.gz</div><div class="line">cd redis-3.2.8</div><div class="line">make </div><div class="line">make test</div><div class="line">make install</div></pre></td></tr></table></figure><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="make出错"><a href="#make出错" class="headerlink" title="make出错"></a>make出错</h2><p>解决办法：<strong>安装gcc</strong><br>步骤：</p><ul><li>能上网：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install gcc-c++</div></pre></td></tr></table></figure><ul><li>不能上网:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/31/image.png" alt="image.png"></li></ul><h2 id="二次-make出错"><a href="#二次-make出错" class="headerlink" title="二次 make出错"></a>二次 make出错</h2><p>提示：<strong>Jemalloc/jemalloc.h：没有那个文件或目录</strong><br>解决办法：运行<code>make distclean</code>之后再<code>make</code></p><h2 id="make-test出错"><a href="#make-test出错" class="headerlink" title="make test出错"></a>make test出错</h2><p>报如下错误，不过不影响安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">!!! WARNING The following tests failed:</div><div class="line"></div><div class="line">*** [err]: Server is able to generate a stack trace on selected systems in tests/integration/logging.tcl</div><div class="line">expected stack trace not found into log file</div><div class="line">Cleanup: may take some time... OK</div><div class="line">make[1]: *** [test] Error 1</div><div class="line">make[1]: Leaving directory `/usr/local/redis-3.2.8/src&apos;</div><div class="line">make: *** [test] Error 2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      安装单机版的Redis。最近接触了很多redis场景和配置，碰到很多生产和测试环境的各种问题，现在来重现以及解决。
    
    </summary>
    
      <category term="redis" scheme="https://liuzhongpo.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://liuzhongpo.github.io/tags/redis/"/>
    
      <category term="CentOS" scheme="https://liuzhongpo.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>【zookeeper】Curator实现基于zookeeper的分布式锁</title>
    <link href="https://liuzhongpo.github.io/2018/01/23/%E3%80%90zookeeper%E3%80%91Curator%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Ezookeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://liuzhongpo.github.io/2018/01/23/【zookeeper】Curator实现基于zookeeper的分布式锁/</id>
    <published>2018-01-22T16:00:00.000Z</published>
    <updated>2018-01-23T03:55:20.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式锁理论"><a href="#分布式锁理论" class="headerlink" title="分布式锁理论"></a>分布式锁理论</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要<strong>牺牲强一致性来换取系统的高可用性</strong>，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，在集群环境中都是多个JVM协同工作，需要一些全局锁，那么就要利用分布式锁来解决这些问题。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说<strong>单纯的Java Api并不能提供分布式锁的能力</strong>。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul><li>基于数据库实现分布式锁 </li><li>基于缓存（redis，memcached，tair）实现分布式锁</li><li>基于Zookeeper实现分布式锁</li></ul><h2 id="分布式锁是什么？"><a href="#分布式锁是什么？" class="headerlink" title="分布式锁是什么？"></a>分布式锁是什么？</h2><ul><li>保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</li><li>锁是可重入锁，避免死锁</li><li>锁是阻塞锁，根据业务需求考虑是否需要</li><li>高可用和高性能的获取锁和释放锁</li></ul><p>归根结底：<strong>利用一个互斥方能够访问的公共资源来实现分布式锁</strong>，具体这个公共资源是redis来setnx，还是zookeeper，相反没有这么重要。</p><h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-client&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure><h1 id="Zookeeper锁原理"><a href="#Zookeeper锁原理" class="headerlink" title="Zookeeper锁原理"></a>Zookeeper锁原理</h1><ol><li>首先要创建一个锁的根节点，比如/mylock。</li><li><p>想要获取锁的客户端在锁的根节点下面创建znode，作为/mylock的子节点，节点的类型要选择CreateMode.PERSISTENT_SEQUENTIAL（默认创建为CreateMode.EPHEMERAL_SEQUENTIAL），节点的名字最好用uuid（如果不这么做在某种情况下会发生死锁），假设目前同时有3个客户端想要获得锁，那么/mylock下的目录应该是这个样子的。xxx为uuid ， 0000000001，0000000002，0000000003 是zook服务端自动生成的自增数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xxx-lock-0000000001，xxx-lock-0000000002，xxx-lock-0000000003</div></pre></td></tr></table></figure></li><li><p>当前客户端通过getChildren（/mylock）获取所有子节点列表并根据自增数字排序，然后判断一下自己创建的节点的顺序是不是在列表当中最小的，如果是 那么获取到锁，如果不是，那么获取自己的前一个节点，并设置监听这个节点的变化，当节点变化时重新执行步骤3 直到自己是编号最小的一个为止举例：假设当前客户端创建的节点是0000000002，因为它的编号不是最小的，所以获取不到锁，那么它就找到它前面的一个节点0000000001 并对它设置监听。</p></li><li>释放锁，当前获得锁的客户端在操作完成后删除自己创建的节点，这样会激发zookeeper的事件给其它客户端知道，这样其它客户端会重新执行（步骤3）。举例：加入客户端0000000001获取到锁，然后客户端0000000002加入进来获取锁，发现自己不是编号最小的，那么它会监听它前面节点的事件（0000000001的事件）然后执行步骤（3），当客户端0000000001操作完成后删除自己的节点，这时zook服务端会发送事件，这时客户端0000000002会接收到该事件，然后重复步骤3直到获取到锁）</li></ol><p>上面的步骤实现了一个<strong>有序锁</strong>，也就是先进入等待锁的客户端在锁可用时先获得锁。如果想要实现一个随机锁，那么只需要把子节点名称后的自增数字换成一个随机数即可。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLock</span> </span>&#123;</div><div class="line">    <span class="comment">/** zookeeper地址 */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.40.40:2181,192.168.40.41:2181,192.168.40.42:2181"</span>;</div><div class="line">    <span class="comment">/** session超时时间 */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_OUTTIME = <span class="number">5000</span>;<span class="comment">//ms</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</div><div class="line">        CuratorFramework cf = CuratorFrameworkFactory.builder()</div><div class="line">                .connectString(CONNECT_ADDR)</div><div class="line">                .sessionTimeoutMs(SESSION_OUTTIME)</div><div class="line">                .retryPolicy(retryPolicy)</div><div class="line">                .build();</div><div class="line">        cf.start();</div><div class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(cf, <span class="string">"/mylock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.acquire();</div><div class="line">            System.out.println(<span class="string">"已经获取到锁"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.release();</div><div class="line">        &#125;</div><div class="line">        Thread.sleep(<span class="number">10000</span>);</div><div class="line">        cf.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码解释：</p><ul><li>InterProcessMutex 是线程安全的，一个JVM创建一个就好。</li><li>mylock为锁的根目录，我们可以针对不同业务创建不同的根目录。</li><li>lock.acquire()会阻塞方法，获取不到锁的线程会挂起。</li><li>lock.release()释放锁，必须要放到finally里面，已确保上面方法出现异常时也能够释放锁。<h3 id="节点图"><a href="#节点图" class="headerlink" title="节点图"></a>节点图</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/23/image.png" alt="image.png"><h2 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h2><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLockThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="comment">//启动10个线程模拟多个客户端</span></div><div class="line">            JvmLock jl = <span class="keyword">new</span> JvmLock(i);</div><div class="line">            <span class="keyword">new</span> Thread(jl).start();</div><div class="line">            <span class="comment">//这里加上300毫秒是为了让线程按顺序启动，不然有可能4号线程比3号线程先启动了，这样测试就不准了。</span></div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="comment">/** zookeeper地址 */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.40.40:2181,192.168.40.41:2181,192.168.40.42:2181"</span>;</div><div class="line">        <span class="comment">/** session超时时间 */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_OUTTIME = <span class="number">5000</span>;<span class="comment">//ms</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">JvmLock</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.num = num;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</div><div class="line">            CuratorFramework cf = CuratorFrameworkFactory.builder()</div><div class="line">                    .connectString(CONNECT_ADDR)</div><div class="line">                    .sessionTimeoutMs(SESSION_OUTTIME)</div><div class="line">                    .retryPolicy(retryPolicy)</div><div class="line">                    .build();</div><div class="line">            cf.start();</div><div class="line">            InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(cf, <span class="string">"/mylock"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(<span class="string">"我是第"</span> + num + <span class="string">"号线程，我开始获取锁"</span>);</div><div class="line">                lock.acquire();</div><div class="line">                System.out.println(<span class="string">"我是第"</span> + num + <span class="string">"号线程，我已经获取锁"</span>);</div><div class="line">                Thread.sleep(<span class="number">10000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.release();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            cf.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>代码解释：</p><ul><li>那如果NODE0拿到了锁，而在执行锁内业务的时候 服务器挂了之类的行为，那那个NODE不是永远不会被删除，那后面的节点不是一直阻塞在那了吗？这是个临时节点，如果服务器没有收到客户端的心跳连接，则服务器会依据sessionid，将该节点删除的。<h3 id="节点图-1"><a href="#节点图-1" class="headerlink" title="节点图"></a>节点图</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/23/image558ba.png" alt="image558ba.png"></li></ul><h2 id="非公平锁版"><a href="#非公平锁版" class="headerlink" title="非公平锁版"></a>非公平锁版</h2><h3 id="重写创建节点方法"><a href="#重写创建节点方法" class="headerlink" title="重写创建节点方法"></a>重写创建节点方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoFairLockDriver</span> <span class="keyword">extends</span> <span class="title">StandardLockInternalsDriver</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 随机数的长度</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numLength;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">5</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoFairLockDriver</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_LENGTH);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoFairLockDriver</span><span class="params">(<span class="keyword">int</span> numLength)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numLength = numLength;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        String newPath = path + getRandomSuffix();</div><div class="line">        String ourPath;</div><div class="line">        <span class="keyword">if</span>(lockNodeBytes != <span class="keyword">null</span>)&#123;</div><div class="line">            ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL).forPath(newPath, lockNodeBytes);</div><div class="line">            <span class="comment">//ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL).forPath(newPath);</div><div class="line">            <span class="comment">//ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ourPath;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得随机数字符串</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRandomSuffix</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numLength; i++) &#123;</div><div class="line">            sb.append((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码解释：</p><ul><li>原来使用的是CreateMode.EPHEMERAL_SEQUENTIAL类型的节点，节点名称最终是这样的_c_c8e86826-d3dd-46cc-8432-d91aed763c2e-lock-0000000025。</li><li>其中0000000025是zook服务器端资自动生成的自增序列 从0000000000开始，所以每个客户端创建节点的顺序都是按照0，1，2，3这样递增的顺序排列的，所以他们获取锁的顺序与他们进入的顺序是一致的，这也就是所谓的公平锁。</li><li>现在将有序的编号换成随机的数字，这样在获取锁的时候变成非公平锁。</li></ul><h3 id="注册新类"><a href="#注册新类" class="headerlink" title="注册新类"></a>注册新类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(cf,<span class="string">"/mylock"</span>, <span class="keyword">new</span> NoFairLockDriver());</div></pre></td></tr></table></figure><h3 id="节点图-2"><a href="#节点图-2" class="headerlink" title="节点图"></a>节点图</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/23/image01f2f.png" alt="image01f2f.png"></p><p><strong>代码地址：</strong> <a href="https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper/src/main/java/com/lzp/lock" target="_blank" rel="noopener">https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper/src/main/java/com/lzp/lock</a> </p>]]></content>
    
    <summary type="html">
    
      由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，那么就要利用分布式锁来解决这些问题。
    
    </summary>
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/tags/zookeeper/"/>
    
      <category term="Curator" scheme="https://liuzhongpo.github.io/tags/Curator/"/>
    
      <category term="分布式锁" scheme="https://liuzhongpo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>【zookeeper】Curator基础</title>
    <link href="https://liuzhongpo.github.io/2018/01/21/%E3%80%90zookeeper%E3%80%91Curator%E5%9F%BA%E7%A1%80/"/>
    <id>https://liuzhongpo.github.io/2018/01/21/【zookeeper】Curator基础/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-01-21T08:53:56.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curator是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端、zkClient相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator目前是Apache的顶级项目，里面提供了更多丰富的操作，例如session超时重连、主从选举、分布式计数器、分布式锁等等适用于各种复杂的zookeeper场景的API封装。</p><h1 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h1><h2 id="创建和开启连接"><a href="#创建和开启连接" class="headerlink" title="创建和开启连接"></a>创建和开启连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** zookeeper地址 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.40.40:2181,192.168.40.41:2181,192.168.40.42:2181"</span>;</div><div class="line"><span class="comment">/** session超时时间 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_OUTTIME = <span class="number">5000</span>;<span class="comment">//ms</span></div><div class="line"><span class="comment">//1 重试策略：初试时间为1S，重试10次</span></div><div class="line">RetryPolicy retry = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</div><div class="line"><span class="comment">//2 通过工厂创建连接</span></div><div class="line">CuratorFramework cf = CuratorFrameworkFactory.builder()</div><div class="line">        .connectString(CONNECT_ADDR)</div><div class="line">        .sessionTimeoutMs(SESSION_OUTTIME)</div><div class="line">        .retryPolicy(retry)</div><div class="line">        .build();</div><div class="line"><span class="comment">//3 开启连接</span></div><div class="line">cf.start();</div></pre></td></tr></table></figure><p>参数解释：</p><ul><li>connectString 连接串</li><li>sessionTimeoutMs 会话超时时间，默认为60 000 ms</li><li>retryPolicy 重试连接策略。有四种实现分别为ExponentialBackoffRetry、RetryNTimes、RetryOneTimes、RetryUntilElapsed</li><li>connectionTimeoutMs 连接超时时间，默认为15 000ms</li></ul><p><strong>注意：对于retryPolicy策略通过一个接口来让用户自定义实现。</strong></p><h2 id="新加和删除节点"><a href="#新加和删除节点" class="headerlink" title="新加和删除节点"></a>新加和删除节点</h2><p>创建节点create方法：可选链式项：createParentsIfNeeded、withMode、forPath、withACL等<br>删除节点delete方法，可选链式项：deletingChildrenIfNeeded、guaranteed、withVersion、forPath等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4 建立节点 指定节点类型(不加withMode默认为持久类型节点)、路径、数据内容</span></div><div class="line">cf.create().creatingParentsIfNeeded()</div><div class="line">        .withMode(CreateMode.PERSISTENT)</div><div class="line">        .forPath(<span class="string">"/super/c1"</span>,<span class="string">"c1内容"</span>.getBytes());</div><div class="line"><span class="comment">//5 删除节点</span></div><div class="line">cf.delete().guaranteed().deletingChildrenIfNeeded().forPath(<span class="string">"/super"</span>);</div></pre></td></tr></table></figure></p><h2 id="读取和修改节点"><a href="#读取和修改节点" class="headerlink" title="读取和修改节点"></a>读取和修改节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取、修改</span></div><div class="line"><span class="comment">// 创建节点</span></div><div class="line">cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/super/c1"</span>,<span class="string">"c1内容"</span>.getBytes());</div><div class="line">cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/super/c2"</span>,<span class="string">"c2内容"</span>.getBytes());</div><div class="line"><span class="comment">//读取节点</span></div><div class="line">String ret1 = <span class="keyword">new</span> String(cf.getData().forPath(<span class="string">"/super/c2"</span>));</div><div class="line">System.out.println(ret1);</div><div class="line"><span class="comment">//修改节点</span></div><div class="line">cf.setData().forPath(<span class="string">"/super/c2"</span>,<span class="string">"c2更新内容"</span>.getBytes());</div><div class="line">String ret2 = <span class="keyword">new</span> String(cf.getData().forPath(<span class="string">"/super/c2"</span>));</div><div class="line">System.out.println(ret2);</div></pre></td></tr></table></figure><h2 id="绑定回调函数"><a href="#绑定回调函数" class="headerlink" title="绑定回调函数"></a>绑定回调函数</h2><p>异步绑定回调方法。比如创建节点时绑定一个回调函数，该回调函数可以输出服务器的状态码以及服务器事件类型。还可以加入一个线程池进行优化操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ExecutorService pool = Executors.newCachedThreadPool();</div><div class="line">cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT)</div><div class="line">        .inBackground(new BackgroundCallback() &#123;</div><div class="line">            @Override</div><div class="line">            public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception &#123;</div><div class="line">                System.out.println(&quot;code:&quot;+ curatorEvent.getResultCode());</div><div class="line">                System.out.println(&quot;type:&quot;+ curatorEvent.getType());</div><div class="line">                System.out.println(&quot;当前线程:&quot;+ Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;,pool)</div><div class="line">        .forPath(&quot;/super/c3&quot;,&quot;c3内容&quot;.getBytes());</div></pre></td></tr></table></figure></p><h2 id="读取子节点"><a href="#读取子节点" class="headerlink" title="读取子节点"></a>读取子节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取子节点getChildren方法和判断节点是否存在checkExists方法</span></div><div class="line">List&lt;String&gt; list = cf.getChildren().forPath(<span class="string">"/super"</span>);</div><div class="line"><span class="keyword">for</span>(String s : list) &#123;</div><div class="line">    System.out.println(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//checkExists()  不存在节点，返回的stat为null。存在则返回的stat结构体信息</span></div><div class="line">Stat stat = cf.checkExists().forPath(<span class="string">"/super"</span>);</div><div class="line">System.out.println(stat);</div></pre></td></tr></table></figure><h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p>如果要使用类似Watch的监听功能，Curator必须依赖一个jar包，maven依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p><p>有了这个依赖包，我们使用NodeCache的方式去客户端实例中注册一个监听缓存，然后实现对应的监听方法即可。这里我们主要有两种监听方式：</p><ul><li>NodeCacheListener：监听节点的新增、修改操作</li><li>PathChildrenCacheListener：监听子节点的新增、修改、删除操作</li></ul><h2 id="NodeCacheListener"><a href="#NodeCacheListener" class="headerlink" title="NodeCacheListener"></a>NodeCacheListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4 建立一个cache缓存</span></div><div class="line"><span class="keyword">final</span> NodeCache cache = <span class="keyword">new</span> NodeCache(cf, <span class="string">"/super"</span>, <span class="keyword">false</span>);</div><div class="line"><span class="comment">//boolean buildInitial:是否构建的时候初始化</span></div><div class="line">cache.start(<span class="keyword">true</span>);</div><div class="line">cache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"路径为："</span> + cache.getCurrentData().getPath());</div><div class="line">        System.out.println(<span class="string">"数据为："</span> + <span class="keyword">new</span> String(cache.getCurrentData().getData()));</div><div class="line">        System.out.println(<span class="string">"状态为："</span> + cache.getCurrentData().getStat());</div><div class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>代码解释：<br>1、NodeCache<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure></p><ul><li>CuratorFramework client：连接</li><li>String path : 节点的路径</li><li>boolean dataIsCompressed: 是否压缩数据，不写底层默认为false</li></ul><p>2、cache.start(true)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> buildInitial)</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;</div></pre></td></tr></table></figure></p><ul><li>boolean buildInitial:是否构建的时候初始化</li></ul><h2 id="PathChildren…"><a href="#PathChildren…" class="headerlink" title="PathChildren…"></a>PathChildren…</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4 建立一个PathChildrenCache缓存，第三个参数是否为接收节点数据内容</span></div><div class="line">PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(cf, <span class="string">"/super"</span>, <span class="keyword">false</span>);</div><div class="line"><span class="comment">//5 在初始化的时候就进行缓存监听</span></div><div class="line">cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</div><div class="line">cache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 新建、修改、删除</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getType()) &#123;</div><div class="line">            <span class="keyword">case</span> CHILD_ADDED:</div><div class="line">                System.out.println(<span class="string">"CHILD_ADDED :"</span> + event.getData().getPath());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> CHILD_UPDATED:</div><div class="line">                System.out.println(<span class="string">"CHILD_UPDATED :"</span> + event.getData().getPath());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> CHILD_REMOVED:</div><div class="line">                System.out.println(<span class="string">"CHILD_REMOVED :"</span> + event.getData().getPath());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><p>代码解释：<br>1、PathChildrenCache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PathChildrenCache(CuratorFramework client, String path, boolean cacheData)&#123;...&#125;</div></pre></td></tr></table></figure></p><ul><li>CuratorFramework client：连接</li><li>String path : 节点的路径</li><li>boolean cacheData: 是否缓存数据，这里一般是为true</li></ul><p>2、cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> buildInitial)</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;</div></pre></td></tr></table></figure></p><ul><li>PathChildrenCache.StartMode.POST_INITIALIZED_EVENT:在初始化的时候就进行缓存监听</li></ul>]]></content>
    
    <summary type="html">
    
      之前接触使用到Curator,与Zookeeper提供的原生客户端、zkClient相比,里面提供了更多丰富的操作，很有必要学习和总结。
    
    </summary>
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/tags/zookeeper/"/>
    
      <category term="Curator" scheme="https://liuzhongpo.github.io/tags/Curator/"/>
    
  </entry>
  
  <entry>
    <title>【zookeeper】集群搭建</title>
    <link href="https://liuzhongpo.github.io/2018/01/20/%E3%80%90zookeeper%E3%80%91%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://liuzhongpo.github.io/2018/01/20/【zookeeper】集群搭建/</id>
    <published>2018-01-19T16:00:00.000Z</published>
    <updated>2018-01-20T10:14:58.953Z</updated>
    
    <content type="html"><![CDATA[<ul><li>前提条件：3台虚拟机，zookeeper压缩包</li></ul><h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>以下流程，在集群的机器上都做一遍。<br>1、在zookeeper下创建mydata文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir mydata</div></pre></td></tr></table></figure></p><p>2、进入 zookeeper下的conf文件夹，新建 zoo.cfg文件（拷贝zoo_sample.cfg）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp zoo_sample.cfg zoo.cfg</div></pre></td></tr></table></figure></p><p>3、编辑zoo.cfg<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim zoo.cfg</div></pre></td></tr></table></figure></p><ul><li>修改datadir为前面mydata的路径，可以利用pwd查看</li><li>在最后面添加server的列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.0=192.168.40.40:2008:6008  </div><div class="line">server.1=192.168.40.41:2008:6008  </div><div class="line">server.2=192.168.40.42:2008:6008</div></pre></td></tr></table></figure></li></ul><p>4、在各自mydata下面创建myid的文件，在里面写入server的数字(根据ip对应的server.?的?)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim myid</div></pre></td></tr></table></figure></p><p>5、启动zookeeper</p><ul><li>启动命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh start</div></pre></td></tr></table></figure><ul><li>查看状态：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/zkServer.sh status</div></pre></td></tr></table></figure><p><img src="http://s1.wailian.download/2018/01/20/image.png" alt="image.png"><br><img src="http://s1.wailian.download/2018/01/20/image650e2.png" alt="image650e2.png"></p><h1 id="server列表解释"><a href="#server列表解释" class="headerlink" title="server列表解释"></a>server列表解释</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）。这个配置项的书写格式比较特殊，规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.N=YYY:A:B</div></pre></td></tr></table></figure></p><ul><li>N表示服务器编号</li><li>YYY表示服务器的IP地址</li><li>A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口</li><li>B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）</li></ul><h1 id="zookeeper异常"><a href="#zookeeper异常" class="headerlink" title="zookeeper异常"></a>zookeeper异常</h1><p>Zookeeper启动异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error contacting service. It is probably not running.</div></pre></td></tr></table></figure></p><p>可能原因：</p><ol><li>重试几次，要是还失败，就可能是下面的原因</li><li>zoo.cfg配置文件有问题</li><li>zoo.cfg配置文件中指定目录却没有创建！ 创建相应目录即可。</li><li><p>zoo.cfg中dataDir指定路径为myid文件的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myid内容与：server.?=localhost:2888:3888 中你所设置？一致！</div></pre></td></tr></table></figure></li><li><p>使用<code>service iptables stop</code> 关闭防火墙,使用<code>service iptables status</code>确认</p></li></ol>]]></content>
    
    <summary type="html">
    
      zookeeper集群搭建。
    
    </summary>
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【zookeeper】基础知识及操作</title>
    <link href="https://liuzhongpo.github.io/2018/01/08/%E3%80%90zookeeper%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
    <id>https://liuzhongpo.github.io/2018/01/08/【zookeeper】基础知识以及操作/</id>
    <published>2018-01-07T16:00:00.000Z</published>
    <updated>2018-01-08T03:25:26.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用官方的说法：“Zookeeper是一个高性能，分布式的，开源分布式应用协调服务。它提供了简单原始的功能，分布式应用可以基于它实现更高级 的服务，比如同步，配置管理，集群管理，命名空间。它被设计为易于编程，使用文件系统目录树作为数据模型。服务端跑在java上，提供java和C的客户端 API”。也可以理解为：<strong>zookeeper = 文件系统+通知机制。</strong></p><ul><li>功能作用：命名服务、配置维护、集群管理、分布式消息同步和协调机制、负载均衡、对Dubbo支持。Zoopkeeper提供了一套很好的分布式集群管理的机制，就是它这种<strong>基于层次型的目录树的数据结构，并对树中的节点进行有效管理</strong>，从而可以设计出多种多样的分布式的数据管理模型，作为分布式系统的沟通调度桥梁。</li><li>下载地址：<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image.png" alt="image.png"></li></ul><h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p>前期准备：官网下载安装包，本次版本zookeeper-3.4.9.tar.gz，拷贝至/opt目录下。</p><ol><li><p>解压：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf zookeeper-3.4.9.tar.gz</div></pre></td></tr></table></figure></li><li><p>新建专属zookeeper目录：mkdir /myzookeeper，随后将上一步解压的zookeeper内容拷贝进/myzookeeper目录内，拷贝：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -rf  zookeeper-3.4.9 /myzookeeper/ zookeeper-3.4.9</div></pre></td></tr></table></figure></li><li><p>进入conf文件夹，拷贝zoo_sample.cfg改为zoo.cfg：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp zoo_sample.cfg zoo.cfg</div></pre></td></tr></table></figure></li><li><p>开启服务以及客户端连接<br>a)    进入/myzookeeper/zookeeper-3.4.9/bin路径下<br>b)    启动服务：<code>./zkServer.sh start</code><br>c)    停止服务：<code>./zkServer stop</code><br>d)    客户端连接：<code>./zkCli.sh</code><br>e)    客户端退出：<code>quit</code></p></li></ol><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看+获得zookeeper服务器上的数据存储信息，Zookeeper维护一个类似文件系统的数据结构。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image54bc0.png" alt="image54bc0.png"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个Znode。很显然zookeeper集群自身维护了一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为”znode”，每一个znode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/imagef5df3.png" alt="imagef5df3.png"></p><h1 id="数据模型Znode"><a href="#数据模型Znode" class="headerlink" title="数据模型Znode"></a>数据模型Znode</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper内部维护了一套类型UNIX的树形数据结构：由znode构成的集合，znode的集合又是一个树形结构，每一个znode又有很多属性进行描述。Znode维护了一个stat结构体，stat包含数据变化的版本号、访问控制列表变化、时间戳等等。版本号和时间戳一起可让Zookeeper验证缓存和协调更新。每次znode的数据发生了变化，版本号就增加。例如，无论何时客户端检索数据，它也一起检索数据的版本号。并且当客户端执行更新或删除时，客户端必须提供他正在改变的znode的版本号。如果它提供的版本号和真实的数据版本号不一致，更新将会失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/imageb8b4b.png" alt="imageb8b4b.png"></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image408b2.png" alt="image408b2.png"><br>znode是由客户端创建的，它和创建它的客户端的内在联系，决定了它的存在性：</p><ul><li>PERSISTENT-持久化节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点也不会被删除（除非您使用API强制删除）。</li><li>PERSISTENT_SEQUENTIAL-持久化顺序编号节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当客户端与zookeeper服务的连接断开后，这个节点也不会被删除。</li><li>EPHEMERAL-临时目录节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点（还有涉及到的子节点）就会被删除。</li><li>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当创建这个节点的客户端与zookeeper服务的连接断开后，这个节点被删除。</li><li>另外，无论是EPHEMERAL还是EPHEMERAL_SEQUENTIAL节点类型，在zookeeper的client异常终止后，节点也会被删除</li></ul><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="常用基础命令"><a href="#常用基础命令" class="headerlink" title="常用基础命令"></a>常用基础命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zookeeper表现为一个分层的文件系统目录树结构,不同于文件系统之处在于：zk节点可以有自己的数据，而unix文件系统中的目录节点只有子节点。 <strong>一个节点对应一个应用，节点存储的数据就是应用需要的配置信息。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image73822.png" alt="image73822.png"></p><h3 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper支持某些特定的四字命令，他们大多是用来查询ZK服务的当前状态及相关信息的，通过telnet或nc向zookeeper提交相应命令，如：echo ruok | nc 127.0.0.1 2181<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行公式：<strong>echo 四字命令 | nc 主机IP zookeeper端口</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/imagec508a.png" alt="imagec508a.png"></p><h1 id="Java-Client"><a href="#Java-Client" class="headerlink" title="Java Client"></a>Java Client</h1><p>请参考：<a href="https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper" target="_blank" rel="noopener">https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper</a></p><h1 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>客户端使用某种语言绑定创建一个到服务的句柄时，就建立了一个ZooKeeper会话。会话创建后，句柄处于CONNECTING状态，客户端库会试图连接到组成ZooKeeper服务的某个服务器；连接成功则进入到CONNECTED状态。通常操作中句柄将处于这两个状态之一。如果发生不可恢复的错误，如会话过期、身份鉴定失败，或者应用显式关闭，则句柄进入到CLOSED状态。下图显式了ZooKeeper客户端可能的状态转换：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image63f03.png" alt="image63f03.png"></p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><h3 id="通知机制-1"><a href="#通知机制-1" class="headerlink" title="通知机制"></a>通知机制</h3><ul><li>通知机制：客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。是一种 异步回调的触发机制。</li><li>ZooKeeper 支持watch(观察)的概念。客户端可以在每个znode结点上设置一个观察。如果被观察服务端的znode结点有变更，那么watch就会被触发，这个watch所属的客户端将接收到一个通知包被告知结点已经发生变化，把相应的事件通知给设置Watcher的Client端。</li><li>Zookeeper里的所有读取操作：getData(),getChildren()和exists()都有设置watch的选项</li></ul><h3 id="watch事件理解"><a href="#watch事件理解" class="headerlink" title="watch事件理解"></a>watch事件理解</h3><ul><li>一次触发<br>当数据有了变化时zkserver向客户端发送一个watch,它是一次性的动作，即触发一次就不再有效，类似一次性纸杯。只监控一次。如果想继续Watch的话，需要客户端重新设置Watcher。因此如果你得到一个watch事件且想在将来的变化得到通知，必须新设置另一个watch。</li><li>发往客户端<br>Watches是异步发往客户端的，Zookeeper提供一个顺序保证：在看到watch事件之前绝不会看到变化，这样不同客户端看到的是一致性的顺序。<br>   在（导致观察事件被触发的）修改操作的成功返回码到达客户端之前，事件可能在去往客户端的路上，但是可能不会到达客户端。观察事件是异步地发送给观察者（客户端）的。ZooKeeper会保证次序：在收到观察事件之前，客户端不会看到已经为之设置观察的节点的改动。网络延迟或者其他因素可能会让不同的客户端在不同的时间收到观察事件和更新操作的返回码。这里的要点是：不同客户端看到的事情都有一致的次序。</li><li>为数据设置watch<br>节点有不同的改动方式。可以认为ZooKeeper维护两个观察列表：数据观察和子节点观察。getData()和exists()设置数据观察。getChildren()设置子节点观察。此外，还可以认为不同的返回数据有不同的观察。getData()和exists()返回节点的数据，而getChildren()返回子节点列表。所以，setData()将为znode触发数据观察。成功的create()将为新创建的节点触发数据观察，为其父节点触发子节点观察。成功的delete()将会为被删除的节点触发数据观察以及子节点观察（因为节点不能再有子节点了），为其父节点触发子节点观察。<br>观察维护在客户端连接到的ZooKeeper服 务器中。这让观察的设置、维护和分发是轻量级的。客户端连接到新的服务器时，所有会话事件将被触发。同服务器断开连接期间不会收到观察。客户端重新连接 时，如果需要，先前已经注册的观察将被重新注册和触发。通常这都是透明的。有一种情况下观察事件将丢失：对还没有创建的节点设置存在观察，而在断开连接期 间创建节点，然后删除。</li><li>时序性和一致性<br>Watches是在client连接到Zookeeper服务端的本地维护，这可让watches成为轻量的，可维护的和派发的。当一个client连接到新server，watch将会触发任何session事件，断开连接后不能接收到。当客户端重连，先前注册的watches将会被重新注册并触发。<br>关于watches，Zookeeper维护这些保证：<br>（1）Watches和其他事件、watches和异步恢复都是有序的。Zookeeper客户端保证每件事都是有序派发<br>（2）客户端在看到新数据之前先看到watch事件<br>（3）对应更新顺序的watches事件顺序由Zookeeper服务所见</li></ul>]]></content>
    
    <summary type="html">
    
      众所周知，分布式协调服务很难正确无误的实现，它们很容易在竞争条件和死锁上犯错误。如何在这方面节省力气？Zookeeper是一个不错的选择。
    
    </summary>
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://liuzhongpo.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】单例模式</title>
    <link href="https://liuzhongpo.github.io/2017/12/12/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://liuzhongpo.github.io/2017/12/12/【设计模式】单例模式/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2017-12-12T14:16:07.297Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在GoF的23种设计模式中，单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。这里主要介绍5种写法。</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下写法，是基于classloader机制，避免了多线程的同步问题，但在加载时没有达到lazy loading的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="懒汉式-非线程安全"><a href="#懒汉式-非线程安全" class="headerlink" title="懒汉式-非线程安全"></a>懒汉式-非线程安全</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下写法，lazy loading很明显，但是致命的是在多线程不能正常工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种写法能在多线程中很好的工作，而且具备lazy loading，但同步方法效率很低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种写法是比较推崇的一种写法。加锁双重检查对效率也有一定影响，不过影响不大。流程分析：为了防止new Singleton被执行多次，因此在new操作之前加Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubbleSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DubbleSingleton ds;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubbleSingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubbleSingleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(ds == <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">synchronized</span> (DubbleSingleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(ds == <span class="keyword">null</span>)&#123;</div><div class="line">                    ds = <span class="keyword">new</span> DubbleSingleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ds;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方式:InnerSingleton类被装载了，Singletion不一定被初始化。因为Singletion类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类。有效的实现了 lazy loading，同时也避免加锁。本质上利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletion</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singletion single = <span class="keyword">new</span> Singletion();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singletion <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singletion.single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终问题：静态内部类的实现方式虽好，但是存在着单例模式共同的问题：无法防止利用反射来重复构建对象。</p><h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了enum语法糖，JVM会组织反射获取枚举类的私有构造方法。使用枚举类实现的单例模式不仅能够防止反射构造对象，而且可以保证线程安全。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种方式也有唯一的缺点，就是它并非使用懒加载，其单例对象实在枚举类被加载的时候进行初始化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p><img src="http://s1.wailian.download/2017/12/12/image.png" alt="image.png"></p><p><strong>注意注意</strong>：</p><ul><li>volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。有关volatile的详细原理，我在以后的漫画中会专门讲解。</li><li>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。</li><li>对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。</li></ul>]]></content>
    
    <summary type="html">
    
      老生常谈，记录单例模式常见的几种写法。加班太疯狂，许久没更新博客。这次完善一下单例模式。
    
    </summary>
    
      <category term="设计模式" scheme="https://liuzhongpo.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://liuzhongpo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程创建的4种方式</title>
    <link href="https://liuzhongpo.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%844%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://liuzhongpo.github.io/2017/11/10/线程创建的4种方式/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2017-11-10T00:12:17.267Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java多线程实现方式主要有四种：<strong>继承Thread类、实现Runnable接口、实现Callable接口通过FutureTask包装器来创建Thread线程、使用ExecutorService Callable Future实现有返回结果的多线程</strong>。其中前两种方式线程执行完后都没有返回值，后两种是带返回值的。</p><h1 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的start()实例方法,start()方法是一个native方法，run()方法作为线程执行体被执行。开发步骤如下：</p><ul><li>创建一个类继承Thread类并重写run()方法</li><li>实例化该类new MyThread()</li><li>调用线程的start()方法启动线程</li><li>run()作为线程执行体被执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">　　 System.out.println(<span class="string">"MyThread run() start..."</span>);  </div><div class="line">　　&#125;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();  </div><div class="line">MyThread myThread2 = <span class="keyword">new</span> MyThread();  </div><div class="line">myThread1.start();  </div><div class="line">myThread2.start();</div></pre></td></tr></table></figure><h1 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java中是单继承，所以上种方式有很大的局限性。实现Runnable接口。启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例，开发步骤如下：</p><ul><li>创建一个类实现Runnable接口并重写run()方法</li><li>实例化该类new MyThread(),或者new Thread(new MyThread())</li><li>调用线程的start()方法启动线程</li><li>run()作为线程执行体被执行<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">　　 System.out.println(<span class="string">"MyThread.run()"</span>);  </div><div class="line">　　&#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">//伪代码</span></div><div class="line">MyThread myThread = <span class="keyword">new</span> MyThread();  </div><div class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);  </div><div class="line">thread.start();</div></pre></td></tr></table></figure></li></ul><p>本质上，当传入一个Runnable target参数给Thread后，Thread的run()方法就会调用target.run()，以JDK1.8为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Runnable target;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">      target.run();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h1><p>这种方式创建线程，可以进行异步计算，涉及到 future设计模式。</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>Callable接口（也只有一个方法）定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>通过Callable接口创建线程,开发步骤如下：</p><ul><li>创建Callable接口的实现类，重写call()方法作为线程执行体，该方法有返回值</li><li>创建Callable接口类的实例，使用FutureTask类来包装该实例</li><li>将FutureTask对象作为Thread类的target创建启动线程</li><li>使用FutureTask的get()方法获取子线程call()方法的返回值。主线程将在get()方法处阻塞等待子线程执行完成<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=<span class="number">100</span>;i++) &#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</div><div class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(myThread);</div><div class="line">        <span class="keyword">new</span> Thread(futureTask).start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Integer result = futureTask.get();</div><div class="line">            System.out.println(result);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Future接口是Java线程Future模式的实现（一种异步计算模式），可以来进行异步计算，并支持返回计算结果，在调用get()获取到计算结果前可以阻塞调用者线程。<br>Future模式可以这样来描述：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。就相当于下了一张订货单，一段时间后可以拿着提订单来提货，这期间可以干别的任何事情。其中Future接口就是订货单，真正处理订单的是Executor类，它根据Future接口的要求来生产产品。</p><h3 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FutureTask是JDK针对与future模式的一种实现,它除了支持future特有的特点，还支持task的一些操作，比如取消，打断。一个FutureTask就是一个任务的计算单元，是调度的最小单位，它的调度借助于JDK的Executor任务调度模型。需要开发人员创建好FutureTask对象后，并送入到Executor去等待调度。<br>执行过程：</p><ol><li>创建一个futureTask对象task，提交task到调度器executor等待调度</li><li>等待调度……</li><li><p>如果此时currentThread调取执行结果task.get(),会有几种情况:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> task 还没有被executor调度或正在执行中</div><div class="line">        阻塞当前线程，并加入到一个阻塞链表中waitNode</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> task被其它Thread取消，并取消成功 或task处于打断状态</div><div class="line">        <span class="keyword">throw</span> exception</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> task执行完毕，返回执行结果，或执行存在异常，返回异常信息</div></pre></td></tr></table></figure></li><li><p>如果此时有另外一个线程调用task.get() ,执行过程同上.</p></li></ol><p>注意：executor在执行FutureTask前，会先判断是否被取消，如果取消就不在执行，但执行后就不可以在取消了.</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>在 futureTask定义task的状态有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;  <span class="comment">//创建</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>; <span class="comment">//完成</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>; <span class="comment">//</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>; <span class="comment">//invoke task 出现异常</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>; <span class="comment">//cancel task </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; <span class="comment">// interrupt task</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</div></pre></td></tr></table></figure></p><p>创建一个FutureTask(创建futureTask只需要需要一个callable对象或runnable对象的参数，并在创建时设置状态为NEW):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>调用get()方法获取执行结果方法—awaitDone():<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</div><div class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>executor 调度是执行的方法-run(),本质上调用了call()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (state != NEW ||!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,<span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                result = c.call();<span class="comment">//调用了call()</span></div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        ....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseFuture</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</div><div class="line">   <span class="keyword">private</span> String para;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">UseFuture</span><span class="params">(String para)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.para = para;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">/**</span></div><div class="line"><span class="comment">    * 这里是真实的业务逻辑，其执行可能很慢</span></div><div class="line"><span class="comment">    */</span></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      <span class="comment">//模拟执行耗时</span></div><div class="line">      Thread.sleep(<span class="number">5000</span>);</div><div class="line">      String result = <span class="keyword">this</span>.para + <span class="string">"处理完成"</span>;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="comment">//主控制函数</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">      String queryStr = <span class="string">"query"</span>;</div><div class="line">      <span class="comment">//构造FutureTask，并且传入需要真正进行业务逻辑处理的类,该类一定是实现了Callable接口的类</span></div><div class="line">      FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> UseFuture(queryStr));</div><div class="line">      </div><div class="line">      FutureTask&lt;String&gt; future2 = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> UseFuture(queryStr));</div><div class="line">      <span class="comment">//创建一个固定线程的线程池且线程数为1,</span></div><div class="line">      ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</div><div class="line">      <span class="comment">//这里提交任务future,则开启线程执行RealData的call()方法执行</span></div><div class="line">      <span class="comment">//submit和execute的区别： 第一点是submit可以传入实现Callable接口的实例对象， 第二点是submit方法有返回值</span></div><div class="line">      </div><div class="line">      Future f1 = executor.submit(future);      <span class="comment">//单独启动一个线程去执行的</span></div><div class="line">      Future f2 = executor.submit(future2);</div><div class="line">      System.out.println(<span class="string">"请求完毕"</span>);</div><div class="line">      </div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         <span class="comment">//这里可以做额外的数据操作，也就是主程序执行其他业务逻辑</span></div><div class="line">         System.out.println(<span class="string">"处理实际的业务逻辑..."</span>);</div><div class="line">         Thread.sleep(<span class="number">1000</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//调用获取数据方法,如果call()方法没有执行完成,则依然会进行等待</span></div><div class="line">      System.out.println(<span class="string">"数据："</span> + future.get());</div><div class="line">      System.out.println(<span class="string">"数据："</span> + future2.get());</div><div class="line">      </div><div class="line">      executor.shutdown();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>执行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请求完毕</div><div class="line">处理实际的业务逻辑...</div><div class="line"><span class="comment">// 这里阻塞着，等待异步计算完成</span></div><div class="line">数据：query处理完成</div><div class="line">数据：query处理完成</div></pre></td></tr></table></figure></p><h1 id="线程池ExecutorService"><a href="#线程池ExecutorService" class="headerlink" title="线程池ExecutorService"></a>线程池ExecutorService</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特征，可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。具体demo请参考上述的 Future的demo。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。</strong></p>]]></content>
    
    <summary type="html">
    
      上次技术分享会，分享了一些并发常用的设计模型，其中刚好涉及futuer模式，这与线程的一种方式相关，汇总一下线程的创建方式。
    
    </summary>
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【Netty】Hello Netty</title>
    <link href="https://liuzhongpo.github.io/2017/10/29/Netty%E7%AC%94%E8%AE%B0(%E4%B8%80)%EF%BC%9AHello%20Netty/"/>
    <id>https://liuzhongpo.github.io/2017/10/29/Netty笔记(一)：Hello Netty/</id>
    <published>2017-10-28T16:00:00.000Z</published>
    <updated>2017-11-11T15:24:29.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty概述"><a href="#Netty概述" class="headerlink" title="Netty概述"></a>Netty概述</h2><h3 id="什么是Netty概述？"><a href="#什么是Netty概述？" class="headerlink" title="什么是Netty概述？"></a>什么是Netty概述？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Netty是由JBOSS提供的一个java开源框架。Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。通俗的讲，Netty 是一个基于NIO的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty相当简化和流线化了网络应用的编程开发过程，例如，TCP和UDP的socket服务开发。</p><h3 id="netty和tomcat区别"><a href="#netty和tomcat区别" class="headerlink" title="netty和tomcat区别"></a>netty和tomcat区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Netty和Tomcat最大的区别就在于通信协议，Tomcat是基于Http协议的，他的实质是一个基于http协议的web容器，但是Netty不一样，他能通过编程自定义各种协议，因为netty能够通过codec自己来编码/解码字节流，完成类似redis访问的功能，这就是netty和tomcat最大的不同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人说netty的性能就一定比tomcat性能高，其实不然，tomcat从6.x开始就支持了nio模式，并且后续还有arp模式——一种通过jni调用apache网络库的模式，相比于旧的bio模式，并发性能得到了很大提高，特别是arp模式，而netty是否比tomcat性能更高，则要取决于netty程序开发者的技术实力了。</p><h3 id="为什么选择netty？"><a href="#为什么选择netty？" class="headerlink" title="为什么选择netty？"></a>为什么选择netty？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因：并发高、传输快、封装好。</p><ul><li>并发高：Netty是一款基于NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架，对比于BIO（Blocking I/O，阻塞IO），他的并发性能得到了很大提高。</li><li>传输快：一般我们的数据如果需要从IO读取到堆内存，中间需要经过Socket缓冲区，也就是说一个数据会被拷贝两次才能到达他的的终点，如果数据量大，就会造成不必要的资源浪费。Netty针对这种情况，使用了NIO中的另一大特性——零拷贝，当他需要接收数据的时候，他会在堆内存之外开辟一块内存，数据就直接从IO读到了那块内存中去，在Netty里面通过ByteBuf可以直接对这些数据进行直接操作，从而加快了传输速度。</li><li>封装好：Netty的内部实现很复杂，但是Netty隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架，解耦业务逻辑。</li></ul><h2 id="Netty体系结构图"><a href="#Netty体系结构图" class="headerlink" title="Netty体系结构图"></a>Netty体系结构图</h2><p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2017/10/29/image.png" alt="image.png"></p><h2 id="Netty之HelloWorld"><a href="#Netty之HelloWorld" class="headerlink" title="Netty之HelloWorld"></a>Netty之HelloWorld</h2><ul><li>server端：ServerHandler和Server。</li><li>client端：ClientHandler和Client。<br><strong>基于Netty5.0和JDK1.6及以上</strong><h3 id="ServerHandler"><a href="#ServerHandler" class="headerlink" title="ServerHandler"></a>ServerHandler</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ServerHandler是事件处理器，该处理器是由Netty生成用来处理I/O事件的。但是Netty的处理器遵循<strong>DISCARD服务</strong>(丢弃服务，指的是会忽略所有接收的数据的一种协议)，以及在<strong>ECHO协议</strong>的实现下编写一个响应消息给客户端，这个协议针对任何接收的数据都会返回一个响应。。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//do something msg</span></div><div class="line">            <span class="comment">// 接收客户端数据</span></div><div class="line">            ByteBuf buf = (ByteBuf) msg;</div><div class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</div><div class="line">            buf.readBytes(data);</div><div class="line">            System.out.println(<span class="keyword">new</span> String(data,<span class="string">"utf-8"</span>));</div><div class="line">            <span class="comment">// 给客户端反馈</span></div><div class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"我是服务器端的反馈"</span>.getBytes())).addListener(ChannelFutureListener.CLOSE);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ReferenceCountUtil.release(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>代码详解：</p><ol><li>ServerHandler 继承自 ChannelHandlerAdapter，这个类实现了ChannelHandler接口，ChannelHandler提供了许多事件处理的接口方法，然后你可以覆盖这些方法。现在仅仅只需要继承ChannelHandlerAdapter类而不是你自己去实现接口方法。</li><li>覆盖了chanelRead()事件处理方法。每当从客户端收到新的数据时，这个方法会在收到消息时被调用，这个例子中，收到的消息的类型是ByteBuf，msg即为ByteBuf类型。</li><li>为了实现DISCARD协议，处理器不得不忽略所有接受到的消息。ByteBuf是一个引用计数对象，这个对象必须显示地调用release()方法来释放或者在finally里ReferenceCountUtil.release(msg);。请记住<strong>处理器的职责</strong>是释放所有传递到处理器的引用计数对象。</li><li>exceptionCaught()事件处理方法是当出现Throwable对象才会被调用，即当Netty由于IO错误或者处理器在处理事件时抛出的异常时。在大部分情况下，捕获的异常应该被记录下来并且把关联的channel给关闭掉。然而这个方法的处理方式会在遇到不同异常的情况下有不同的实现，比如你可能想在关闭连接之前发送一个错误码的响应消息。</li></ol><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编写一个main()方法来启动服务端的ServerHandler。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//1、创建两个线程组</span></div><div class="line">        <span class="comment">//bossGroup用于接收Client的连接</span></div><div class="line">        NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="comment">//workGroup用于实际的业务处理操作</span></div><div class="line">        NioEventLoopGroup workGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//2、启动NIO服务的辅助启动类，对server进行配置</span></div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">            <span class="comment">//3、对server进行配置</span></div><div class="line">            <span class="comment">//把两个线程组加入进来</span></div><div class="line">            b.group(bossGroup, workGroup)</div><div class="line">                    <span class="comment">// 指定NioServerSocketChannel类型的通道</span></div><div class="line">                    .channel(NioServerSocketChannel.class)</div><div class="line">                    <span class="comment">// 使用childHandler绑定具体的 事件处理器</span></div><div class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> ServerHandler());</div><div class="line">                        &#125;</div><div class="line">                    &#125;)</div><div class="line">                    <span class="comment">// 设置tcp缓冲区</span></div><div class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</div><div class="line">                    <span class="comment">// 保持连接</span></div><div class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</div><div class="line">            <span class="comment">//4、绑定端口，启动server</span></div><div class="line">            ChannelFuture f = b.bind(<span class="number">9876</span>).sync();</div><div class="line">            <span class="comment">//5、阻塞server</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            workGroup.shutdownGracefully();</div><div class="line">            bossGroup.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码详解：</p><ol><li>NioEventLoopGroup 是用来处理I/O操作的多线程事件循环器，Netty提供了许多不同的EventLoopGroup的实现用来处理不同传输协议。在这个例子中我们实现了一个服务端的应用，因此会有2个NioEventLoopGroup会被使用。第一个经常被叫做‘boss’，用来接收进来的连接。第二个经常被叫做‘worker’，用来处理已经被接收的连接，一旦‘boss’接收到连接，就会把连接信息注册到‘worker’上。如何知道多少个线程已经被使用，如何映射到已经创建的Channels上都需要依赖于EventLoopGroup的实现，并且可以通过构造函数来配置他们的关系。</li><li>ServerBootstrap 是一个启动NIO服务的辅助启动类。你可以在这个服务中直接使用Channel，但是这会是一个复杂的处理过程，在很多情况下你并不需要这样做。</li><li>channel(NioServerSocketChannel.class)，指定使用NioServerSocketChannel类来举例说明一个新的Channel如何接收进来的连接，即通道。</li><li>childHandler(new ChannelInitializer<socketchannel>()，这里的事件处理类经常会被用来处理一个最近的已经接收的Channel。ChannelInitializer是一个特殊的处理类，他的目的是帮助使用者配置一个新的Channel。也许你想通过增加一些处理类比如ServerHandle来配置一个新的Channel或者其对应的ChannelPipeline来实现你的网络程序。当你的程序变的复杂时，可能你会增加更多的处理类到pipline上，然后提取这些匿名类到最顶层的类上。</socketchannel></li><li>option，设置这里指定的通道实现的配置参数。我们正在写一个TCP/IP的服务端，因此我们被允许设置socket的参数选项比如tcpNoDelay和keepAlive。</li><li>你关注过option()和childOption()吗？option()是提供给NioServerSocketChannel用来接收进来的连接。childOption()是提供给由父管道ServerChannel接收到的连接，在这个例子中也是NioServerSocketChannel。</li><li>绑定端口然后启动服务。</li></ol><h3 id="ClientHandler"><a href="#ClientHandler" class="headerlink" title="ClientHandler"></a>ClientHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandlerAdapter</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//do something msg</span></div><div class="line">            <span class="comment">// 接收服务器端反馈</span></div><div class="line">            ByteBuf buf = (ByteBuf) msg;</div><div class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buf.readableBytes()];</div><div class="line">            buf.readBytes(data);</div><div class="line">            String request = <span class="keyword">new</span> String(data, <span class="string">"utf-8"</span>);</div><div class="line">            System.out.println(<span class="string">"Client: "</span> + request);</div><div class="line">            <span class="comment">// 客户端发送给服务器端的数据</span></div><div class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"我是客户端的反馈"</span>.getBytes()));</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            ReferenceCountUtil.release(msg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        cause.printStackTrace();</div><div class="line">        ctx.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Netty中,编写服务端和客户端最大的并且唯一不同的使用了不同的BootStrap和Channel的实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        EventLoopGroup workgroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        Bootstrap b = <span class="keyword">new</span> Bootstrap();</div><div class="line">        b.group(workgroup)</div><div class="line">                .channel(NioSocketChannel.class)</div><div class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                        sc.pipeline().addLast(<span class="keyword">new</span> ClientHandler());</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">        ChannelFuture cf1 = b.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9876</span>).sync();</div><div class="line">        <span class="comment">//buf，获取管道，写入数据</span></div><div class="line">        cf1.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="string">"777"</span>.getBytes()));</div><div class="line">        cf1.channel().closeFuture().sync();</div><div class="line">        workgroup.shutdownGracefully();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码详解：</p><ol><li>BootStrap和ServerBootstrap类似,不过他是对非服务端的channel而言，比如客户端或者无连接传输模式的channel。</li><li>如果你只指定了一个EventLoopGroup，那他就会即作为一个‘boss’线程，也会作为一个‘workder’线程，尽管客户端不需要使用到‘boss’线程。</li><li>代替NioServerSocketChannel的是NioSocketChannel,这个类在客户端channel被创建时使用。</li><li>不像在使用ServerBootstrap时需要用childOption()方法，因为客户端的SocketChannel没有父channel的概念。</li><li>我们用connect()方法代替了bind()方法。</li></ol><h3 id="TIME服务"><a href="#TIME服务" class="headerlink" title="TIME服务"></a>TIME服务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个部分被实现的协议是TIME协议。和之前的例子不同的是在不接受任何请求时他会发送一个含32位的整数的消息，并且一旦消息发送就会立即关闭连接。在这个例子中，你会学习到如何构建和发送一个消息，然后在完成时主动关闭连接。因为我们将会忽略任何接收到的数据，而只是在连接被创建发送一个消息，所以这次我们不能使用channelRead()方法了，代替他的是，我们需要覆盖channelActive()方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx)</span> </span>&#123; <span class="comment">// (1)</span></div><div class="line">    <span class="keyword">final</span> ByteBuf time = ctx.alloc().buffer(<span class="number">4</span>); <span class="comment">// (2)</span></div><div class="line">    time.writeInt((<span class="keyword">int</span>) (System.currentTimeMillis() / <span class="number">1000L</span> + <span class="number">2208988800L</span>));</div><div class="line">    <span class="keyword">final</span> ChannelFuture f = ctx.writeAndFlush(time); <span class="comment">// (3)</span></div><div class="line">    f.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</div><div class="line">            <span class="keyword">assert</span> f == future;</div><div class="line">            ctx.close();</div><div class="line">        &#125;</div><div class="line">    &#125;); <span class="comment">// (4)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>代码详解：</p><ol><li>channelActive()方法将会在连接被建立并且准备进行通信时被调用。因此让我们在这个方法里完成一个代表当前时间的32位整数消息的构建工作。</li><li>为了发送一个新的消息，我们需要分配一个包含这个消息的新的缓冲。因为我们需要写入一个32位的整数，因此我们需要一个至少有4个字节的ByteBuf。通过ChannelHandlerContext.alloc()得到一个当前的ByteBufAllocator，然后分配一个新的缓冲。</li><li><p>之前ByteBuffer的flip在哪？难道我们使用NIO发送消息时不是调用java.nio.ByteBuffer.flip()吗？ByteBuf之所以没有这个方法因为Netty做了封装，原理为：ByteBuf有两个指针，一个对应读操作一个对应写操作。当你向ByteBuf里写入数据的时候写指针的索引就会增加，同时读指针的索引没有变化。读指针索引和写指针索引分别代表了消息的开始和结束。比较起来，NIO缓冲并没有提供一种简洁的方式来计算出消息内容的开始和结尾，除非你调用flip方法。当你忘记调用flip方法而引起没有数据或者错误数据被发送时，你会陷入困境。这样的一个错误不会发生在Netty上，因为我们对于不同的操作类型有不同的指针。习惯一种没有使用flip的方式。另外一个点需要注意的是ChannelHandlerContext.write()(和writeAndFlush())方法会返回一个ChannelFuture对象，一个ChannelFuture代表了一个还没有发生的I/O操作。这意味着任何一个请求操作都不会马上被执行，因为在Netty里所有的操作都是异步的。举个例子下面的代码中在消息被发送之前可能会先关闭连接。因此你需要在write()方法返回的ChannelFuture完成后调用close()方法，然后当他的写操作已经完成他会通知他的监听者。请注意,close()方法也可能不会立马关闭，他也会返回一个ChannelFuture。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Channel ch = ...;</div><div class="line">ch.writeAndFlush(message);</div><div class="line">ch.close();</div></pre></td></tr></table></figure></li><li><p>当一个写请求已经完成是如何通知到我们？这个只需要简单地在返回的ChannelFuture上增加一个ChannelFutureListener。这里我们构建了一个匿名的ChannelFutureListener类用来在操作完成时关闭Channel。或者，你可以使用简单的预定义监听器代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">f.addListener(ChannelFutureListener.CLOSE);</div></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      Netty简介，以及入门HelloWorld。
    
    </summary>
    
      <category term="Netty&amp;Mina" scheme="https://liuzhongpo.github.io/categories/Netty-Mina/"/>
    
    
      <category term="Netty" scheme="https://liuzhongpo.github.io/tags/Netty/"/>
    
      <category term="服务器" scheme="https://liuzhongpo.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="https://liuzhongpo.github.io/2017/10/21/Java%20synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://liuzhongpo.github.io/2017/10/21/Java synchronized关键字/</id>
    <published>2017-10-20T16:00:00.000Z</published>
    <updated>2017-11-11T15:21:32.498Z</updated>
    
    <content type="html"><![CDATA[<p>学习synchronized关键字，首先要明白几个多线程的概念。</p><ul><li><strong>线程安全</strong>：当多个线程访问某一个类（对象或方法）始终都能表现出正确的行为，那么这个类（对象或方法）就是线程安全的。</li><li><strong>互斥区或临界区</strong>：synchronized可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区”或“临界区”。</li></ul><h2 id="synchronized的锁级别"><a href="#synchronized的锁级别" class="headerlink" title="synchronized的锁级别"></a>synchronized的锁级别</h2><ul><li><strong>对象锁</strong>：关键字synchronized加在非static方法上（或synchronized锁代码块，直接用对象或者本身this加锁），取得的锁都是对象锁，而不是把一段代码（方法）当作锁，所以代码中哪个线程先执行synchronized关键字的方法，哪个线程就持有该方法所属的对象锁（lock）。 </li><li><strong>类级别锁</strong>：在静态方法上加synchronized关键字（或synchronized锁代码块，直接用 类名.class 加锁），表示锁定.class类，类级别的锁（独占.class类）。<h3 id="对象锁"><a href="#对象锁" class="headerlink" title="对象锁"></a>对象锁</h3></li></ul><ol><li><p>synchronized关键字加在非静态方法上，对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title">method</span> <span class="params">()</span></span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>synchronized关键字加在代码块上，用this或者其他对象加锁，都是对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;  <span class="comment">//对象锁</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="类级别锁"><a href="#类级别锁" class="headerlink" title="类级别锁"></a>类级别锁</h3><ol><li><p>synchronized关键字加在 static方法上，类级别锁，独占.class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>synchronized关键字加在代码块上，用 本类名.class加锁，类级别锁，独占.class。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;     <span class="comment">//类锁</span></div><div class="line">   <span class="keyword">synchronized</span> (ObjectLock.class) &#123;      </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="多个线程多个锁"><a href="#多个线程多个锁" class="headerlink" title="多个线程多个锁"></a>多个线程多个锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的线程，对象锁不同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread02</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">   <span class="comment">/** static */</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(String tag)</span></span>&#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         <span class="keyword">if</span>(tag.equals(<span class="string">"a"</span>))&#123;</div><div class="line">            num = <span class="number">100</span>;</div><div class="line">            System.out.println(<span class="string">"tag a, set num over!"</span>);</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">            num = <span class="number">200</span>;</div><div class="line">            System.out.println(<span class="string">"tag b, set num over!"</span>);</div><div class="line">         &#125;</div><div class="line">         System.out.println(<span class="string">"tag "</span> + tag + <span class="string">", num = "</span> + num);</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line">   &#125; </div><div class="line">   <span class="comment">//注意观察run方法输出顺序</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="comment">//俩个不同的线程对象，synchronized加在非static方法，对应的对象锁也不同。解决：方法加static</span></div><div class="line">      <span class="keyword">final</span> MyThread02 m1 = <span class="keyword">new</span> MyThread02();</div><div class="line">      <span class="keyword">final</span> MyThread02 m2 = <span class="keyword">new</span> MyThread02();</div><div class="line">      </div><div class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            m1.printNum(<span class="string">"a"</span>);</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">      Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">         <span class="meta">@Override</span> </div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            m2.printNum(<span class="string">"b"</span>);</div><div class="line">         &#125;</div><div class="line">      &#125;);       </div><div class="line">      t1.start();</div><div class="line">      t2.start();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h3 id="锁对象问题"><a href="#锁对象问题" class="headerlink" title="锁对象问题"></a>锁对象问题</h3><ul><li>注意1：不要使用String常量加锁，会造成死循环。String常量池的缓存功能。</li><li>注意2：修改锁对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  1. 当使用一个对象进行加锁的时候，要注意对象本身发生改变的时候，那么持有的锁对象就不同。（可以理解为：对象的地址值不发生改变）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  2. 如果对象本身不发生改变，那么依然是同步，即使是对象的属性发生了改变。</li><li>注意3：死锁问题，在设计程序时就应该避免双方相互持有对方的锁的情况。<h2 id="锁的同步和异步"><a href="#锁的同步和异步" class="headerlink" title="锁的同步和异步"></a>锁的同步和异步</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3></li><li>同步（synchronized）：同步的概念就是共享，如果不是共享资源就没有必要进行同步。</li><li>异步（asynchronized）：异步的概念就是独立，相互之间不受到任何制约。比如，学习http的时候，在页面发起aj加锁的时候ax请求，我们还可以继续浏览</li><li>同步的目的：为了线程安全。其实对于线程安全来说，需要满足两个特性，原子性（同步）和可见性。</li><li>总结：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1. A线程现持有Object对象的Lock锁，B线程如果在这个时候调用对象中的同步（synchronized）方法则需要等待，也就是同步。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2. A线程现持有Object对象的Lock锁，B线程可以以异步的方式调用对象中的非synchronized修饰的方法。<h3 id="【问题】脏读"><a href="#【问题】脏读" class="headerlink" title="【问题】脏读"></a>【问题】脏读</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于对象的同步和异步的方法，在设计程序的时候，一定要考虑问题的整体，不然就会出现数据不一致的错误，很经典的错误就是脏读（dirtyread）。</li><li>以下代码分析：<br>场景1：setValue 加synchronized，getValue不加synchronized  结果：会出现线程安全问题(脏读)<br>场景2：setValue 加synchronized，getValue加synchronized  结果：等执行setValue，才会执行 getValue，设值取值一致。</li><li>分析：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们对一个对象的方法加锁的时候，需要考虑业务的整体性，即为setValue和getValue方法同时加锁synchronized，保证业务的原子性，不然会出现业务错误(也从侧面保证业务的一致性)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread04</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> String username = <span class="string">"lzp"</span>;</div><div class="line">   <span class="keyword">private</span> String password = <span class="string">"123"</span>;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String username, String password)</span></span>&#123;</div><div class="line">      <span class="keyword">this</span>.username = username;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">         Thread.sleep(<span class="number">2000</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;     </div><div class="line">      <span class="keyword">this</span>.password = password;  </div><div class="line">      System.out.println(<span class="string">"setValue最终结果：username = "</span> + username + <span class="string">" , password = "</span> + password);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// synchronized</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"getValue方法得到：username = "</span> + <span class="keyword">this</span>.username + <span class="string">" , password = "</span> + <span class="keyword">this</span>.password);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">      <span class="keyword">final</span> MyThread04 dr = <span class="keyword">new</span> MyThread04();</div><div class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            dr.setValue(<span class="string">"z3"</span>, <span class="string">"456"</span>);</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">      t1.start();</div><div class="line">      Thread.sleep(<span class="number">1000</span>);  </div><div class="line">      dr.getValue();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><h2 id="锁重入和异常"><a href="#锁重入和异常" class="headerlink" title="锁重入和异常"></a>锁重入和异常</h2><h3 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h3><ol><li><p>同类的同步方法之间的互相调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDubbo1</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"method1.."</span>);</div><div class="line">      method2();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"method2.."</span>);</div><div class="line">      method3();</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</div><div class="line">      System.out.println(<span class="string">"method3.."</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      <span class="keyword">final</span> SyncDubbo1 sd = <span class="keyword">new</span> SyncDubbo1();</div><div class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            sd.method1();</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">      t1.start();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>子类同步方法调用父类的同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncDubbo2</span> </span>&#123;</div><div class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">      <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operationSup</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">            i--;</div><div class="line">            System.out.println(<span class="string">"Main print i = "</span> + i);</div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Main</span> </span>&#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">operationSub</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</div><div class="line">               i--;</div><div class="line">               System.out.println(<span class="string">"Sub print i = "</span> + i);</div><div class="line">               Thread.sleep(<span class="number">100</span>);    </div><div class="line">               <span class="keyword">this</span>.operationSup();</div><div class="line">            &#125;</div><div class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">      &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">      Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">         <span class="meta">@Override</span></div><div class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Sub sub = <span class="keyword">new</span> Sub();</div><div class="line">            sub.operationSub();</div><div class="line">         &#125;</div><div class="line">      &#125;);</div><div class="line">      t1.start();</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于web应用程序，异常释放锁的情况，如果不及时处理，很可能对你的应用程序业务逻辑产生严重的错误，比如你现在执行一个队列任务，很多对象都去在等待第一个对象正确执行完毕再去释放锁，但是第一个对象由于异常的出现，导致业务逻辑没有正常执行就释放了锁，那么可想而知后续的对象执行的都是错误的逻辑。</p><ul><li>同步方法或者代码块里出现异常-分析：</li><li>代码里出现异常，用try…catch…，try 出现运行期异常，比如：Integer.parseInt(“a”); 或者throw new RuntimeException();<ol><li>处理1：catch (InterruptedException e)  则线程到此结束（打断异常）</li><li>处理2：catch里throw new RuntimeException();  则线程到此结束</li><li>处理3：catch (Exception e)   则线程继续</li></ol></li></ul><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized实现线程间的通信，后期再补充Lock锁方式的线程间通信。</p><h3 id="相关概念-1"><a href="#相关概念-1" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>线程通信</strong>：线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。线程间通信就成为整体的必用方式之一。当线程存在通信指挥，系统间的交互性会更强大，在提高CPU利用率的同时还会使开发人员对线程任务在处理过程中进行有效的把控与监督。</li><li>使用wait/notify方法实现线程间的通信。（注意：这两个方法都是Object类的方法，换句话说，Java为所有对象都提供了这两个方法）<ol><li>wait和notify必须配合synchronized关键字使用。</li><li>wait方法释放锁，notify方法不释放锁，sleep方法不释放锁。</li></ol></li></ul><h3 id="wait和notify实现通信"><a href="#wait和notify实现通信" class="headerlink" title="wait和notify实现通信"></a>wait和notify实现通信</h3><ul><li>启动3个线程(包括主线程)，循环打印出A,B,C,100次<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSignal</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(count != <span class="number">1</span>) &#123;</div><div class="line">                wait();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"A"</span>);</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">            count = <span class="number">2</span>;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(count != <span class="number">2</span>) &#123;</div><div class="line">                wait();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"B"</span>);</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">            count = <span class="number">3</span>;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">while</span>(count != <span class="number">3</span>) &#123;</div><div class="line">                wait();</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">"C"</span>);</div><div class="line">            Thread.sleep(<span class="number">500</span>);</div><div class="line">            count = <span class="number">1</span>;</div><div class="line">            notifyAll();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span>  Exception </span>&#123;</div><div class="line">        <span class="keyword">final</span> ThreadSignal signal = <span class="keyword">new</span> ThreadSignal();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;= <span class="number">100</span>;i++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        signal.printA();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;= <span class="number">100</span>;i++) &#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        signal.printB();</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;).start();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ;i &lt;= <span class="number">100</span>;i++) &#123;</div><div class="line">            signal.printC();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      总结synchronized的用法以及碰到的问题
    
    </summary>
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://liuzhongpo.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="synchronized" scheme="https://liuzhongpo.github.io/tags/synchronized/"/>
    
  </entry>
  
</feed>
