<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[【Redis】安装单机版Redis]]></title>
      <url>/2019/08/17/%E3%80%90Redis%E3%80%91%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88Redis/</url>
      <content type="html"><![CDATA[<p>官网下载redis安装包，这里使用：<code>redis-3.2.8.tar.gz</code>。安装在<strong>/usr/local</strong>下。</p>
<h1 id="安装-tcl"><a href="#安装-tcl" class="headerlink" title="安装 tcl"></a>安装 tcl</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget http://downloads.sourceforge.net/tcl/tcl8.6.1-src.tar.gz</div><div class="line">tar -xzvf tcl8.6.1-src.tar.gz</div><div class="line">cd  /usr/local/tcl8.6.1/unix/</div><div class="line">./configure  </div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h1 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar -zxvf redis-3.2.8.tar.gz</div><div class="line">cd redis-3.2.8</div><div class="line">make </div><div class="line">make test</div><div class="line">make install</div></pre></td></tr></table></figure>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="make出错"><a href="#make出错" class="headerlink" title="make出错"></a>make出错</h2><p>解决办法：<strong>安装gcc</strong><br>步骤：</p>
<ul>
<li>能上网：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install gcc-c++</div></pre></td></tr></table></figure>
<ul>
<li>不能上网:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/31/image.png" alt="image.png"></li>
</ul>
<h2 id="二次-make出错"><a href="#二次-make出错" class="headerlink" title="二次 make出错"></a>二次 make出错</h2><p>提示：<strong>Jemalloc/jemalloc.h：没有那个文件或目录</strong><br>解决办法：运行<code>make distclean</code>之后再<code>make</code></p>
<h2 id="make-test出错"><a href="#make-test出错" class="headerlink" title="make test出错"></a>make test出错</h2><p>报如下错误，不过不影响安装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">!!! WARNING The following tests failed:</div><div class="line"></div><div class="line">*** [err]: Server is able to generate a stack trace on selected systems in tests/integration/logging.tcl</div><div class="line">expected stack trace not found into log file</div><div class="line">Cleanup: may take some time... OK</div><div class="line">make[1]: *** [test] Error 1</div><div class="line">make[1]: Leaving directory `/usr/local/redis-3.2.8/src&apos;</div><div class="line">make: *** [test] Error 2</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
            <tag> CentOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【zookeeper】Curator实现基于zookeeper的分布式锁]]></title>
      <url>/2018/06/26/%E3%80%90zookeeper%E3%80%91Curator%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8Ezookeeper%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      <content type="html"><![CDATA[<h1 id="分布式锁理论"><a href="#分布式锁理论" class="headerlink" title="分布式锁理论"></a>分布式锁理论</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式的CAP理论告诉我们“任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。”所以，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要<strong>牺牲强一致性来换取系统的高可用性</strong>，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在平时的工作中，线上服务器是分布式多台部署的，经常会面临解决分布式场景下数据一致性的问题，在集群环境中都是多个JVM协同工作，需要一些全局锁，那么就要利用分布式锁来解决这些问题。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说<strong>单纯的Java Api并不能提供分布式锁的能力</strong>。</p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ul>
<li>基于数据库实现分布式锁 </li>
<li>基于缓存（redis，memcached，tair）实现分布式锁</li>
<li>基于Zookeeper实现分布式锁</li>
</ul>
<h2 id="分布式锁是什么？"><a href="#分布式锁是什么？" class="headerlink" title="分布式锁是什么？"></a>分布式锁是什么？</h2><ul>
<li>保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</li>
<li>锁是可重入锁，避免死锁</li>
<li>锁是阻塞锁，根据业务需求考虑是否需要</li>
<li>高可用和高性能的获取锁和释放锁</li>
</ul>
<p>归根结底：<strong>利用一个互斥方能够访问的公共资源来实现分布式锁</strong>，具体这个公共资源是redis来setnx，还是zookeeper，相反没有这么重要。</p>
<h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;curator-client&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;4.0.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h1 id="Zookeeper锁原理"><a href="#Zookeeper锁原理" class="headerlink" title="Zookeeper锁原理"></a>Zookeeper锁原理</h1><ol>
<li>首先要创建一个锁的根节点，比如/mylock。</li>
<li><p>想要获取锁的客户端在锁的根节点下面创建znode，作为/mylock的子节点，节点的类型要选择CreateMode.PERSISTENT_SEQUENTIAL（默认创建为CreateMode.EPHEMERAL_SEQUENTIAL），节点的名字最好用uuid（如果不这么做在某种情况下会发生死锁），假设目前同时有3个客户端想要获得锁，那么/mylock下的目录应该是这个样子的。xxx为uuid ， 0000000001，0000000002，0000000003 是zook服务端自动生成的自增数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xxx-lock-0000000001，xxx-lock-0000000002，xxx-lock-0000000003</div></pre></td></tr></table></figure>
</li>
<li><p>当前客户端通过getChildren（/mylock）获取所有子节点列表并根据自增数字排序，然后判断一下自己创建的节点的顺序是不是在列表当中最小的，如果是 那么获取到锁，如果不是，那么获取自己的前一个节点，并设置监听这个节点的变化，当节点变化时重新执行步骤3 直到自己是编号最小的一个为止举例：假设当前客户端创建的节点是0000000002，因为它的编号不是最小的，所以获取不到锁，那么它就找到它前面的一个节点0000000001 并对它设置监听。</p>
</li>
<li>释放锁，当前获得锁的客户端在操作完成后删除自己创建的节点，这样会激发zookeeper的事件给其它客户端知道，这样其它客户端会重新执行（步骤3）。举例：加入客户端0000000001获取到锁，然后客户端0000000002加入进来获取锁，发现自己不是编号最小的，那么它会监听它前面节点的事件（0000000001的事件）然后执行步骤（3），当客户端0000000001操作完成后删除自己的节点，这时zook服务端会发送事件，这时客户端0000000002会接收到该事件，然后重复步骤3直到获取到锁）</li>
</ol>
<p>上面的步骤实现了一个<strong>有序锁</strong>，也就是先进入等待锁的客户端在锁可用时先获得锁。如果想要实现一个随机锁，那么只需要把子节点名称后的自增数字换成一个随机数即可。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="简单版"><a href="#简单版" class="headerlink" title="简单版"></a>简单版</h2><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLock</span> </span>&#123;</div><div class="line">    <span class="comment">/** zookeeper地址 */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.40.40:2181,192.168.40.41:2181,192.168.40.42:2181"</span>;</div><div class="line">    <span class="comment">/** session超时时间 */</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_OUTTIME = <span class="number">5000</span>;<span class="comment">//ms</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</div><div class="line">        CuratorFramework cf = CuratorFrameworkFactory.builder()</div><div class="line">                .connectString(CONNECT_ADDR)</div><div class="line">                .sessionTimeoutMs(SESSION_OUTTIME)</div><div class="line">                .retryPolicy(retryPolicy)</div><div class="line">                .build();</div><div class="line">        cf.start();</div><div class="line">        InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(cf, <span class="string">"/mylock"</span>);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            lock.acquire();</div><div class="line">            System.out.println(<span class="string">"已经获取到锁"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.release();</div><div class="line">        &#125;</div><div class="line">        Thread.sleep(<span class="number">10000</span>);</div><div class="line">        cf.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li>InterProcessMutex 是线程安全的，一个JVM创建一个就好。</li>
<li>mylock为锁的根目录，我们可以针对不同业务创建不同的根目录。</li>
<li>lock.acquire()会阻塞方法，获取不到锁的线程会挂起。</li>
<li>lock.release()释放锁，必须要放到finally里面，已确保上面方法出现异常时也能够释放锁。<h3 id="节点图"><a href="#节点图" class="headerlink" title="节点图"></a>节点图</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/23/image.png" alt="image.png"><h2 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h2><h3 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CuratorLockThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="comment">//启动10个线程模拟多个客户端</span></div><div class="line">            JvmLock jl = <span class="keyword">new</span> JvmLock(i);</div><div class="line">            <span class="keyword">new</span> Thread(jl).start();</div><div class="line">            <span class="comment">//这里加上300毫秒是为了让线程按顺序启动，不然有可能4号线程比3号线程先启动了，这样测试就不准了。</span></div><div class="line">            Thread.sleep(<span class="number">100</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="comment">/** zookeeper地址 */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.40.40:2181,192.168.40.41:2181,192.168.40.42:2181"</span>;</div><div class="line">        <span class="comment">/** session超时时间 */</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_OUTTIME = <span class="number">5000</span>;<span class="comment">//ms</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">JvmLock</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.num = num;</div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</div><div class="line">            CuratorFramework cf = CuratorFrameworkFactory.builder()</div><div class="line">                    .connectString(CONNECT_ADDR)</div><div class="line">                    .sessionTimeoutMs(SESSION_OUTTIME)</div><div class="line">                    .retryPolicy(retryPolicy)</div><div class="line">                    .build();</div><div class="line">            cf.start();</div><div class="line">            InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(cf, <span class="string">"/mylock"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(<span class="string">"我是第"</span> + num + <span class="string">"号线程，我开始获取锁"</span>);</div><div class="line">                lock.acquire();</div><div class="line">                System.out.println(<span class="string">"我是第"</span> + num + <span class="string">"号线程，我已经获取锁"</span>);</div><div class="line">                Thread.sleep(<span class="number">10000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    lock.release();</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            cf.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>代码解释：</p>
<ul>
<li>那如果NODE0拿到了锁，而在执行锁内业务的时候 服务器挂了之类的行为，那那个NODE不是永远不会被删除，那后面的节点不是一直阻塞在那了吗？这是个临时节点，如果服务器没有收到客户端的心跳连接，则服务器会依据sessionid，将该节点删除的。<h3 id="节点图-1"><a href="#节点图-1" class="headerlink" title="节点图"></a>节点图</h3>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/23/image558ba.png" alt="image558ba.png"></li>
</ul>
<h2 id="非公平锁版"><a href="#非公平锁版" class="headerlink" title="非公平锁版"></a>非公平锁版</h2><h3 id="重写创建节点方法"><a href="#重写创建节点方法" class="headerlink" title="重写创建节点方法"></a>重写创建节点方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoFairLockDriver</span> <span class="keyword">extends</span> <span class="title">StandardLockInternalsDriver</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 随机数的长度</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numLength;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_LENGTH = <span class="number">5</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoFairLockDriver</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(DEFAULT_LENGTH);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoFairLockDriver</span><span class="params">(<span class="keyword">int</span> numLength)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numLength = numLength;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createsTheLock</span><span class="params">(CuratorFramework client, String path, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        String newPath = path + getRandomSuffix();</div><div class="line">        String ourPath;</div><div class="line">        <span class="keyword">if</span>(lockNodeBytes != <span class="keyword">null</span>)&#123;</div><div class="line">            ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL).forPath(newPath, lockNodeBytes);</div><div class="line">            <span class="comment">//ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, lockNodeBytes);</span></div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL).forPath(newPath);</div><div class="line">            <span class="comment">//ourPath = client.create().creatingParentContainersIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ourPath;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得随机数字符串</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRandomSuffix</span><span class="params">()</span> </span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numLength; i++) &#123;</div><div class="line">            sb.append((<span class="keyword">int</span>) (Math.random() * <span class="number">10</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sb.toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码解释：</p>
<ul>
<li>原来使用的是CreateMode.EPHEMERAL_SEQUENTIAL类型的节点，节点名称最终是这样的_c_c8e86826-d3dd-46cc-8432-d91aed763c2e-lock-0000000025。</li>
<li>其中0000000025是zook服务器端资自动生成的自增序列 从0000000000开始，所以每个客户端创建节点的顺序都是按照0，1，2，3这样递增的顺序排列的，所以他们获取锁的顺序与他们进入的顺序是一致的，这也就是所谓的公平锁。</li>
<li>现在将有序的编号换成随机的数字，这样在获取锁的时候变成非公平锁。</li>
</ul>
<h3 id="注册新类"><a href="#注册新类" class="headerlink" title="注册新类"></a>注册新类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">InterProcessMutex lock = <span class="keyword">new</span> InterProcessMutex(cf,<span class="string">"/mylock"</span>, <span class="keyword">new</span> NoFairLockDriver());</div></pre></td></tr></table></figure>
<h3 id="节点图-2"><a href="#节点图-2" class="headerlink" title="节点图"></a>节点图</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://www.wailian.work/images/2018/01/23/image01f2f.png" alt="image01f2f.png"></p>
<p><strong>代码地址：</strong> <a href="https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper/src/main/java/com/lzp/lock" target="_blank" rel="noopener">https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper/src/main/java/com/lzp/lock</a> </p>
]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> Curator </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【zookeeper】Curator基础]]></title>
      <url>/2018/06/21/%E3%80%90zookeeper%E3%80%91Curator%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Curator是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端、zkClient相比，Curator的抽象层次更高，简化了Zookeeper客户端的开发量。Curator目前是Apache的顶级项目，里面提供了更多丰富的操作，例如session超时重连、主从选举、分布式计数器、分布式锁等等适用于各种复杂的zookeeper场景的API封装。</p>
<h1 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h1><h2 id="创建和开启连接"><a href="#创建和开启连接" class="headerlink" title="创建和开启连接"></a>创建和开启连接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** zookeeper地址 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> String CONNECT_ADDR = <span class="string">"192.168.40.40:2181,192.168.40.41:2181,192.168.40.42:2181"</span>;</div><div class="line"><span class="comment">/** session超时时间 */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SESSION_OUTTIME = <span class="number">5000</span>;<span class="comment">//ms</span></div><div class="line"><span class="comment">//1 重试策略：初试时间为1S，重试10次</span></div><div class="line">RetryPolicy retry = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">10</span>);</div><div class="line"><span class="comment">//2 通过工厂创建连接</span></div><div class="line">CuratorFramework cf = CuratorFrameworkFactory.builder()</div><div class="line">        .connectString(CONNECT_ADDR)</div><div class="line">        .sessionTimeoutMs(SESSION_OUTTIME)</div><div class="line">        .retryPolicy(retry)</div><div class="line">        .build();</div><div class="line"><span class="comment">//3 开启连接</span></div><div class="line">cf.start();</div></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>connectString 连接串</li>
<li>sessionTimeoutMs 会话超时时间，默认为60 000 ms</li>
<li>retryPolicy 重试连接策略。有四种实现分别为ExponentialBackoffRetry、RetryNTimes、RetryOneTimes、RetryUntilElapsed</li>
<li>connectionTimeoutMs 连接超时时间，默认为15 000ms</li>
</ul>
<p><strong>注意：对于retryPolicy策略通过一个接口来让用户自定义实现。</strong></p>
<h2 id="新加和删除节点"><a href="#新加和删除节点" class="headerlink" title="新加和删除节点"></a>新加和删除节点</h2><p>创建节点create方法：可选链式项：createParentsIfNeeded、withMode、forPath、withACL等<br>删除节点delete方法，可选链式项：deletingChildrenIfNeeded、guaranteed、withVersion、forPath等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4 建立节点 指定节点类型(不加withMode默认为持久类型节点)、路径、数据内容</span></div><div class="line">cf.create().creatingParentsIfNeeded()</div><div class="line">        .withMode(CreateMode.PERSISTENT)</div><div class="line">        .forPath(<span class="string">"/super/c1"</span>,<span class="string">"c1内容"</span>.getBytes());</div><div class="line"><span class="comment">//5 删除节点</span></div><div class="line">cf.delete().guaranteed().deletingChildrenIfNeeded().forPath(<span class="string">"/super"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="读取和修改节点"><a href="#读取和修改节点" class="headerlink" title="读取和修改节点"></a>读取和修改节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取、修改</span></div><div class="line"><span class="comment">// 创建节点</span></div><div class="line">cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/super/c1"</span>,<span class="string">"c1内容"</span>.getBytes());</div><div class="line">cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(<span class="string">"/super/c2"</span>,<span class="string">"c2内容"</span>.getBytes());</div><div class="line"><span class="comment">//读取节点</span></div><div class="line">String ret1 = <span class="keyword">new</span> String(cf.getData().forPath(<span class="string">"/super/c2"</span>));</div><div class="line">System.out.println(ret1);</div><div class="line"><span class="comment">//修改节点</span></div><div class="line">cf.setData().forPath(<span class="string">"/super/c2"</span>,<span class="string">"c2更新内容"</span>.getBytes());</div><div class="line">String ret2 = <span class="keyword">new</span> String(cf.getData().forPath(<span class="string">"/super/c2"</span>));</div><div class="line">System.out.println(ret2);</div></pre></td></tr></table></figure>
<h2 id="绑定回调函数"><a href="#绑定回调函数" class="headerlink" title="绑定回调函数"></a>绑定回调函数</h2><p>异步绑定回调方法。比如创建节点时绑定一个回调函数，该回调函数可以输出服务器的状态码以及服务器事件类型。还可以加入一个线程池进行优化操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ExecutorService pool = Executors.newCachedThreadPool();</div><div class="line">cf.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT)</div><div class="line">        .inBackground(new BackgroundCallback() &#123;</div><div class="line">            @Override</div><div class="line">            public void processResult(CuratorFramework curatorFramework, CuratorEvent curatorEvent) throws Exception &#123;</div><div class="line">                System.out.println(&quot;code:&quot;+ curatorEvent.getResultCode());</div><div class="line">                System.out.println(&quot;type:&quot;+ curatorEvent.getType());</div><div class="line">                System.out.println(&quot;当前线程:&quot;+ Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;,pool)</div><div class="line">        .forPath(&quot;/super/c3&quot;,&quot;c3内容&quot;.getBytes());</div></pre></td></tr></table></figure></p>
<h2 id="读取子节点"><a href="#读取子节点" class="headerlink" title="读取子节点"></a>读取子节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取子节点getChildren方法和判断节点是否存在checkExists方法</span></div><div class="line">List&lt;String&gt; list = cf.getChildren().forPath(<span class="string">"/super"</span>);</div><div class="line"><span class="keyword">for</span>(String s : list) &#123;</div><div class="line">    System.out.println(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="判断节点是否存在"><a href="#判断节点是否存在" class="headerlink" title="判断节点是否存在"></a>判断节点是否存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//checkExists()  不存在节点，返回的stat为null。存在则返回的stat结构体信息</span></div><div class="line">Stat stat = cf.checkExists().forPath(<span class="string">"/super"</span>);</div><div class="line">System.out.println(stat);</div></pre></td></tr></table></figure>
<h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch</h1><p>如果要使用类似Watch的监听功能，Curator必须依赖一个jar包，maven依赖：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>有了这个依赖包，我们使用NodeCache的方式去客户端实例中注册一个监听缓存，然后实现对应的监听方法即可。这里我们主要有两种监听方式：</p>
<ul>
<li>NodeCacheListener：监听节点的新增、修改操作</li>
<li>PathChildrenCacheListener：监听子节点的新增、修改、删除操作</li>
</ul>
<h2 id="NodeCacheListener"><a href="#NodeCacheListener" class="headerlink" title="NodeCacheListener"></a>NodeCacheListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4 建立一个cache缓存</span></div><div class="line"><span class="keyword">final</span> NodeCache cache = <span class="keyword">new</span> NodeCache(cf, <span class="string">"/super"</span>, <span class="keyword">false</span>);</div><div class="line"><span class="comment">//boolean buildInitial:是否构建的时候初始化</span></div><div class="line">cache.start(<span class="keyword">true</span>);</div><div class="line">cache.getListenable().addListener(<span class="keyword">new</span> NodeCacheListener() &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 触发事件为创建节点和更新节点，在删除节点的时候并不触发此操作。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"路径为："</span> + cache.getCurrentData().getPath());</div><div class="line">        System.out.println(<span class="string">"数据为："</span> + <span class="keyword">new</span> String(cache.getCurrentData().getData()));</div><div class="line">        System.out.println(<span class="string">"状态为："</span> + cache.getCurrentData().getStat());</div><div class="line">        System.out.println(<span class="string">"---------------------------------------"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>代码解释：<br>1、NodeCache<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NodeCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> dataIsCompressed)</span></span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>CuratorFramework client：连接</li>
<li>String path : 节点的路径</li>
<li>boolean dataIsCompressed: 是否压缩数据，不写底层默认为false</li>
</ul>
<p>2、cache.start(true)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> buildInitial)</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>boolean buildInitial:是否构建的时候初始化</li>
</ul>
<h2 id="PathChildren…"><a href="#PathChildren…" class="headerlink" title="PathChildren…"></a>PathChildren…</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//4 建立一个PathChildrenCache缓存，第三个参数是否为接收节点数据内容</span></div><div class="line">PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(cf, <span class="string">"/super"</span>, <span class="keyword">false</span>);</div><div class="line"><span class="comment">//5 在初始化的时候就进行缓存监听</span></div><div class="line">cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</div><div class="line">cache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener() &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 新建、修改、删除</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (event.getType()) &#123;</div><div class="line">            <span class="keyword">case</span> CHILD_ADDED:</div><div class="line">                System.out.println(<span class="string">"CHILD_ADDED :"</span> + event.getData().getPath());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> CHILD_UPDATED:</div><div class="line">                System.out.println(<span class="string">"CHILD_UPDATED :"</span> + event.getData().getPath());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> CHILD_REMOVED:</div><div class="line">                System.out.println(<span class="string">"CHILD_REMOVED :"</span> + event.getData().getPath());</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>代码解释：<br>1、PathChildrenCache<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public PathChildrenCache(CuratorFramework client, String path, boolean cacheData)&#123;...&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>CuratorFramework client：连接</li>
<li>String path : 节点的路径</li>
<li>boolean cacheData: 是否缓存数据，这里一般是为true</li>
</ul>
<p>2、cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">start</span><span class="params">(<span class="keyword">boolean</span> buildInitial)</span> <span class="keyword">throws</span> Exception</span>&#123;...&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>PathChildrenCache.StartMode.POST_INITIALIZED_EVENT:在初始化的时候就进行缓存监听</li>
</ul>
]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> Curator </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【zookeeper】集群搭建]]></title>
      <url>/2018/06/18/%E3%80%90zookeeper%E3%80%91%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<ul>
<li>前提条件：3台虚拟机，zookeeper压缩包</li>
</ul>
<h1 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h1><p>以下流程，在集群的机器上都做一遍。<br>1、在zookeeper下创建mydata文件夹<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir mydata</div></pre></td></tr></table></figure></p>
<p>2、进入 zookeeper下的conf文件夹，新建 zoo.cfg文件（拷贝zoo_sample.cfg）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp zoo_sample.cfg zoo.cfg</div></pre></td></tr></table></figure></p>
<p>3、编辑zoo.cfg<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim zoo.cfg</div></pre></td></tr></table></figure></p>
<ul>
<li>修改datadir为前面mydata的路径，可以利用pwd查看</li>
<li>在最后面添加server的列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">server.0=192.168.40.40:2008:6008  </div><div class="line">server.1=192.168.40.41:2008:6008  </div><div class="line">server.2=192.168.40.42:2008:6008</div></pre></td></tr></table></figure>
</li>
</ul>
<p>4、在各自mydata下面创建myid的文件，在里面写入server的数字(根据ip对应的server.?的?)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim myid</div></pre></td></tr></table></figure></p>
<p>5、启动zookeeper</p>
<ul>
<li>启动命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh start</div></pre></td></tr></table></figure>
<ul>
<li>查看状态：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/zkServer.sh status</div></pre></td></tr></table></figure>
<p><img src="http://s1.wailian.download/2018/01/20/image.png" alt="image.png"><br><img src="http://s1.wailian.download/2018/01/20/image650e2.png" alt="image650e2.png"></p>
<h1 id="server列表解释"><a href="#server列表解释" class="headerlink" title="server列表解释"></a>server列表解释</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）。这个配置项的书写格式比较特殊，规则如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server.N=YYY:A:B</div></pre></td></tr></table></figure></p>
<ul>
<li>N表示服务器编号</li>
<li>YYY表示服务器的IP地址</li>
<li>A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口</li>
<li>B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）</li>
</ul>
<h1 id="zookeeper异常"><a href="#zookeeper异常" class="headerlink" title="zookeeper异常"></a>zookeeper异常</h1><p>Zookeeper启动异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error contacting service. It is probably not running.</div></pre></td></tr></table></figure></p>
<p>可能原因：</p>
<ol>
<li>重试几次，要是还失败，就可能是下面的原因</li>
<li>zoo.cfg配置文件有问题</li>
<li>zoo.cfg配置文件中指定目录却没有创建！ 创建相应目录即可。</li>
<li><p>zoo.cfg中dataDir指定路径为myid文件的路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myid内容与：server.?=localhost:2888:3888 中你所设置？一致！</div></pre></td></tr></table></figure>
</li>
<li><p>使用<code>service iptables stop</code> 关闭防火墙,使用<code>service iptables status</code>确认</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【zookeeper】基础知识及操作]]></title>
      <url>/2018/06/08/%E3%80%90zookeeper%E3%80%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BB%A5%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h1 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;引用官方的说法：“Zookeeper是一个高性能，分布式的，开源分布式应用协调服务。它提供了简单原始的功能，分布式应用可以基于它实现更高级 的服务，比如同步，配置管理，集群管理，命名空间。它被设计为易于编程，使用文件系统目录树作为数据模型。服务端跑在java上，提供java和C的客户端 API”。也可以理解为：<strong>zookeeper = 文件系统+通知机制。</strong></p>
<ul>
<li>功能作用：命名服务、配置维护、集群管理、分布式消息同步和协调机制、负载均衡、对Dubbo支持。Zoopkeeper提供了一套很好的分布式集群管理的机制，就是它这种<strong>基于层次型的目录树的数据结构，并对树中的节点进行有效管理</strong>，从而可以设计出多种多样的分布式的数据管理模型，作为分布式系统的沟通调度桥梁。</li>
<li>下载地址：<a href="https://zookeeper.apache.org/" target="_blank" rel="noopener">https://zookeeper.apache.org/</a><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image.png" alt="image.png"></li>
</ul>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><h2 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h2><p>前期准备：官网下载安装包，本次版本zookeeper-3.4.9.tar.gz，拷贝至/opt目录下。</p>
<ol>
<li><p>解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -zxvf zookeeper-3.4.9.tar.gz</div></pre></td></tr></table></figure>
</li>
<li><p>新建专属zookeeper目录：mkdir /myzookeeper，随后将上一步解压的zookeeper内容拷贝进/myzookeeper目录内，拷贝：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp -rf  zookeeper-3.4.9 /myzookeeper/ zookeeper-3.4.9</div></pre></td></tr></table></figure>
</li>
<li><p>进入conf文件夹，拷贝zoo_sample.cfg改为zoo.cfg：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp zoo_sample.cfg zoo.cfg</div></pre></td></tr></table></figure>
</li>
<li><p>开启服务以及客户端连接<br>a)    进入/myzookeeper/zookeeper-3.4.9/bin路径下<br>b)    启动服务：<code>./zkServer.sh start</code><br>c)    停止服务：<code>./zkServer stop</code><br>d)    客户端连接：<code>./zkCli.sh</code><br>e)    客户端退出：<code>quit</code></p>
</li>
</ol>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看+获得zookeeper服务器上的数据存储信息，Zookeeper维护一个类似文件系统的数据结构。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image54bc0.png" alt="image54bc0.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个Znode。很显然zookeeper集群自身维护了一套数据结构。这个存储结构是一个树形结构，其上的每一个节点，我们称之为”znode”，每一个znode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/imagef5df3.png" alt="imagef5df3.png"></p>
<h1 id="数据模型Znode"><a href="#数据模型Znode" class="headerlink" title="数据模型Znode"></a>数据模型Znode</h1><h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper内部维护了一套类型UNIX的树形数据结构：由znode构成的集合，znode的集合又是一个树形结构，每一个znode又有很多属性进行描述。Znode维护了一个stat结构体，stat包含数据变化的版本号、访问控制列表变化、时间戳等等。版本号和时间戳一起可让Zookeeper验证缓存和协调更新。每次znode的数据发生了变化，版本号就增加。例如，无论何时客户端检索数据，它也一起检索数据的版本号。并且当客户端执行更新或删除时，客户端必须提供他正在改变的znode的版本号。如果它提供的版本号和真实的数据版本号不一致，更新将会失败。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/imageb8b4b.png" alt="imageb8b4b.png"></p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image408b2.png" alt="image408b2.png"><br>znode是由客户端创建的，它和创建它的客户端的内在联系，决定了它的存在性：</p>
<ul>
<li>PERSISTENT-持久化节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点也不会被删除（除非您使用API强制删除）。</li>
<li>PERSISTENT_SEQUENTIAL-持久化顺序编号节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当客户端与zookeeper服务的连接断开后，这个节点也不会被删除。</li>
<li>EPHEMERAL-临时目录节点：创建这个节点的客户端在与zookeeper服务的连接断开后，这个节点（还有涉及到的子节点）就会被删除。</li>
<li>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：当客户端请求创建这个节点A后，zookeeper会根据parent-znode的zxid状态，为这个A节点编写一个全目录唯一的编号（这个编号只会一直增长）。当创建这个节点的客户端与zookeeper服务的连接断开后，这个节点被删除。</li>
<li>另外，无论是EPHEMERAL还是EPHEMERAL_SEQUENTIAL节点类型，在zookeeper的client异常终止后，节点也会被删除</li>
</ul>
<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="常用基础命令"><a href="#常用基础命令" class="headerlink" title="常用基础命令"></a>常用基础命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Zookeeper表现为一个分层的文件系统目录树结构,不同于文件系统之处在于：zk节点可以有自己的数据，而unix文件系统中的目录节点只有子节点。 <strong>一个节点对应一个应用，节点存储的数据就是应用需要的配置信息。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image73822.png" alt="image73822.png"></p>
<h3 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zookeeper支持某些特定的四字命令，他们大多是用来查询ZK服务的当前状态及相关信息的，通过telnet或nc向zookeeper提交相应命令，如：echo ruok | nc 127.0.0.1 2181<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行公式：<strong>echo 四字命令 | nc 主机IP zookeeper端口</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/imagec508a.png" alt="imagec508a.png"></p>
<h1 id="Java-Client"><a href="#Java-Client" class="headerlink" title="Java Client"></a>Java Client</h1><p>请参考：<a href="https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper" target="_blank" rel="noopener">https://github.com/liuzhongpo/af-learning/tree/master/08-zookeeper</a></p>
<h1 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h1><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>客户端使用某种语言绑定创建一个到服务的句柄时，就建立了一个ZooKeeper会话。会话创建后，句柄处于CONNECTING状态，客户端库会试图连接到组成ZooKeeper服务的某个服务器；连接成功则进入到CONNECTED状态。通常操作中句柄将处于这两个状态之一。如果发生不可恢复的错误，如会话过期、身份鉴定失败，或者应用显式关闭，则句柄进入到CLOSED状态。下图显式了ZooKeeper客户端可能的状态转换：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="http://s1.wailian.download/2018/01/08/image63f03.png" alt="image63f03.png"></p>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><h3 id="通知机制-1"><a href="#通知机制-1" class="headerlink" title="通知机制"></a>通知机制</h3><ul>
<li>通知机制：客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。是一种 异步回调的触发机制。</li>
<li>ZooKeeper 支持watch(观察)的概念。客户端可以在每个znode结点上设置一个观察。如果被观察服务端的znode结点有变更，那么watch就会被触发，这个watch所属的客户端将接收到一个通知包被告知结点已经发生变化，把相应的事件通知给设置Watcher的Client端。</li>
<li>Zookeeper里的所有读取操作：getData(),getChildren()和exists()都有设置watch的选项</li>
</ul>
<h3 id="watch事件理解"><a href="#watch事件理解" class="headerlink" title="watch事件理解"></a>watch事件理解</h3><ul>
<li>一次触发<br>当数据有了变化时zkserver向客户端发送一个watch,它是一次性的动作，即触发一次就不再有效，类似一次性纸杯。只监控一次。如果想继续Watch的话，需要客户端重新设置Watcher。因此如果你得到一个watch事件且想在将来的变化得到通知，必须新设置另一个watch。</li>
<li>发往客户端<br>Watches是异步发往客户端的，Zookeeper提供一个顺序保证：在看到watch事件之前绝不会看到变化，这样不同客户端看到的是一致性的顺序。<pre><code>在（导致观察事件被触发的）修改操作的成功返回码到达客户端之前，事件可能在去往客户端的路上，但是可能不会到达客户端。观察事件是异步地发送给观察者（客户端）的。ZooKeeper会保证次序：在收到观察事件之前，客户端不会看到已经为之设置观察的节点的改动。网络延迟或者其他因素可能会让不同的客户端在不同的时间收到观察事件和更新操作的返回码。这里的要点是：不同客户端看到的事情都有一致的次序。
</code></pre></li>
<li>为数据设置watch<br>节点有不同的改动方式。可以认为ZooKeeper维护两个观察列表：数据观察和子节点观察。getData()和exists()设置数据观察。getChildren()设置子节点观察。此外，还可以认为不同的返回数据有不同的观察。getData()和exists()返回节点的数据，而getChildren()返回子节点列表。所以，setData()将为znode触发数据观察。成功的create()将为新创建的节点触发数据观察，为其父节点触发子节点观察。成功的delete()将会为被删除的节点触发数据观察以及子节点观察（因为节点不能再有子节点了），为其父节点触发子节点观察。<br>观察维护在客户端连接到的ZooKeeper服 务器中。这让观察的设置、维护和分发是轻量级的。客户端连接到新的服务器时，所有会话事件将被触发。同服务器断开连接期间不会收到观察。客户端重新连接 时，如果需要，先前已经注册的观察将被重新注册和触发。通常这都是透明的。有一种情况下观察事件将丢失：对还没有创建的节点设置存在观察，而在断开连接期 间创建节点，然后删除。</li>
<li>时序性和一致性<br>Watches是在client连接到Zookeeper服务端的本地维护，这可让watches成为轻量的，可维护的和派发的。当一个client连接到新server，watch将会触发任何session事件，断开连接后不能接收到。当客户端重连，先前注册的watches将会被重新注册并触发。<br>关于watches，Zookeeper维护这些保证：<br>（1）Watches和其他事件、watches和异步恢复都是有序的。Zookeeper客户端保证每件事都是有序派发<br>（2）客户端在看到新数据之前先看到watch事件<br>（3）对应更新顺序的watches事件顺序由Zookeeper服务所见</li>
</ul>
]]></content>
      
        <categories>
            
            <category> zookeeper </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Redis】Redis Replication（主从复制）]]></title>
      <url>/2018/03/02/%E3%80%90Redis%E3%80%91Redis%20Replication%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="主从搭建-1主2从"><a href="#主从搭建-1主2从" class="headerlink" title="主从搭建(1主2从)"></a>主从搭建(1主2从)</h1><ul>
<li>3台redis实例，ip和redis端口：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">192.168.1.15:6379</div><div class="line">192.168.1.16:6379</div><div class="line">192.168.1.17:6379</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;准备把<code>192.168.1.15</code>作为主，<code>192.168.1.16</code>、<code>192.168.1.17</code>作为从。</p>
<ul>
<li>丛机相关配置修改(6379.conf,原redis.conf)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span> 192.168.1.16 <span class="comment"># 192.168.1.17,绑定本机ip</span></div><div class="line">slaveof 192.168.1.15 6379 <span class="comment"># slaveof  master主机ip 端口号</span></div><div class="line">slave-read-only yes <span class="comment"># 默认就是yes，开启了只读的redis slave node，会拒绝所有的写操作，强制读写分离</span></div></pre></td></tr></table></figure>
<ul>
<li>主机相关配置修改(6379.conf,原redis.conf)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">bind</span> 192.168.1.15</div><div class="line">slave-read-only yes</div></pre></td></tr></table></figure>
<ul>
<li>重启3台redis实例，redis相关查看命令：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">redis-cli -h ipaddr   <span class="comment">#登录指定ip的redis</span></div><div class="line">info replication	  <span class="comment">#查看redis相关信息</span></div></pre></td></tr></table></figure>
<h1 id="replication流程"><a href="#replication流程" class="headerlink" title="replication流程"></a>replication流程</h1><h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><pre><code>1. slave node启动，仅仅保存master node的信息，包括master node的host和ip，但是复制流程没开始。(master host和ip来源根据redis.conf里面的slaveof配置的)。
2. slave node内部有个定时任务，每秒检查是否有新的master node要连接和复制，如果发现，就跟master node建立socket网络连接。
3. slave node发送ping命令给master node。
4. 口令认证，如果master设置了requirepass，那么salve node必须发送masterauth的口令过去进行认证。
5. slave发送PSYNC命令给master，开始数据同步
6. master node第一次执行**全量复制(full resynchronization)**，将所有数据发给slave node。
7. slave node重新连接master node，那么master node仅仅会复制给slave部分缺少的数据(**增量复制**)
</code></pre><ul>
<li>注意事项：<ol>
<li>slave node做复制的时候，是不会block master node的正常工作的。</li>
<li>slave node在做复制的时候，也不会block对自己的查询操作，它会用旧的数据集来提供服务;但是复制完成的时候，需要删除旧数据集，加载新数据集，这个时候就会暂停对外服务了。</li>
<li>slave node主要用来进行横向扩容，做读写分离，扩容的slave node可以提高读的吞吐量。</li>
<li>过期key处理：slave不会过期key，只会等待master过期key。如果master过期了一个key，或者通过LRU淘汰了一个key，那么会模拟一条del命令发送给slave。</li>
<li>全量复制和增量复制，具体还需要根据master run id、backlog、offset来判断是全量还是增量，这几个参数相关解释如下。  </li>
</ol>
</li>
</ul>
<h2 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h2><ol>
<li>master执行<strong>bgsave</strong>，在本地生成一份rdb快照文件。</li>
<li>master node将rdb快照文件发送给salve node，如果rdb复制时间超过60秒（repl-timeout），那么slave node就会认为复制失败，适当调大这个参数(对于千兆网卡的机器，一般每秒传输100MB，6G文件，很可能超过60s)。</li>
<li>master node在生成rdb时，会将所有新的写命令缓存在内存中，在salve node保存了rdb之后，再将新的写命令复制给salve node。</li>
<li><code>client-output-buffer-limit slave 256MB 64MB 60</code> ，如果在复制期间，内存缓冲区持续60s消耗超过64MB，或者一次性超过256MB，那么停止复制，断开复制连接，复制失败。</li>
<li>slave node接收到rdb之后，清空自己的旧数据，然后重新加载rdb到自己的内存中，同时基于薪的数据版本对外提供服务。</li>
<li>如果slave node开启了AOF，那么会立即执行<strong>BGREWRITEAOF</strong>，重写AOF。</li>
</ol>
<ul>
<li>注意事项：<ol>
<li>rdb生成、rdb通过网络拷贝、slave旧数据的清理、slave aof rewrite，很耗费时间。如果复制的数据量在4G~6G之间，那么可能全量复制时间消耗到1分半到2分钟(理论测试值,具体看机器配置以及网络配置)</li>
<li>master在内存中直接创建rdb，然后发送给slave，不会在自己本地落地磁盘保存。</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">repl-diskless-sync no <span class="comment">#默认no</span></div><div class="line">repl-diskless-sync-delay <span class="comment">#等待一定时长再开始复制，因为要等更多slave重新连接过来</span></div></pre></td></tr></table></figure>
<h2 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h2><ol>
<li>如果全量复制过程中，master-slave网络连接断掉，那么salve重新连接master时，会触发增量复制。</li>
<li>master直接从自己的backlog中获取部分丢失的数据，发送给slave node，默认backlog就是1MB。</li>
<li>msater就是根据slave发送的psync中的offset来从backlog中获取数据的。</li>
</ol>
<h2 id="相关参数详解"><a href="#相关参数详解" class="headerlink" title="相关参数详解"></a>相关参数详解</h2><h3 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h3><ul>
<li>master和slave都会维护一个offset，保存在backlog中。</li>
<li>master会在自身不断累加offset，slave也会在自身不断累加offset。</li>
<li>slave每秒都会上报自己的offset给master，同时master也会保存每个slave的offset。</li>
<li>这并不是说特定就用在全量复制的，主要是master和slave都要知道各自的数据的offset，才能知道互相之间的数据不一致的情况。</li>
</ul>
<h3 id="backlog"><a href="#backlog" class="headerlink" title="backlog"></a>backlog</h3><ul>
<li>master node有一个backlog，默认是1MB大小。</li>
<li>master node给slave node复制数据时，也会将数据在backlog中同步写一份。</li>
<li>backlog主要是用来做全量复制中断时候的增量复制的。</li>
</ul>
<h3 id="master-run-id"><a href="#master-run-id" class="headerlink" title="master run id"></a>master run id</h3><ul>
<li><code>info server</code>，可以看到master run id。</li>
<li>如果根据host+ip定位master node是不靠谱，，如果master node重启或者数据出现了变化，那么slave node应该根据不同的run id区分，run id不同就做全量复制。</li>
<li>如果需要不更改run id重启redis，可以使用<code>redis-cli debug reload</code>命令。</li>
</ul>
<h3 id="psync"><a href="#psync" class="headerlink" title="psync"></a>psync</h3><ul>
<li>从节点使用psync从master node进行复制，psync runid offset。</li>
<li>master node会根据自身的情况返回响应信息，可能是FULLRESYNC runid，offset触发全量复制，可能是CONTINUE触发增量复制。</li>
</ul>
<h3 id="hearbeat和异步复制"><a href="#hearbeat和异步复制" class="headerlink" title="hearbeat和异步复制"></a>hearbeat和异步复制</h3><ul>
<li>Hearbeat：主从节点互相都会发送heartbeat信息，master默认每隔10秒发送一次heartbeat，salve node每隔1秒发送一个heartbeat。</li>
<li>异步复制：master每次接收到写命令之后，现在内部写入数据，然后异步发送给slave node。(redis 2.8开始，slave node会周期性地确认自己每次复制的数据量)</li>
</ul>
<h1 id="master持久化"><a href="#master持久化" class="headerlink" title="master持久化"></a>master持久化</h1><ul>
<li>采用了主从架构，那么建议必须开启master node的持久化！不建议用slave node作为master node的数据热备。<br>因为如果你关掉master的持久化，可能在master宕机重启的时候数据是空的，然后可能一经过复制，salve node数据也丢了<ul>
<li>master -&gt; RDB和AOF都关闭了 -&gt; 全部在内存中。</li>
<li>master宕机，重启，是没有本地数据可以恢复的，然后就会直接认为自己的数据是空的。</li>
<li>master就会将空的数据集同步到slave上去，所有slave的数据全部清空。100%的数据丢失。</li>
</ul>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，master节点，必须要使用持久化机制。</p>
<ul>
<li>master的各种备份方案也需要做，如果万一本地的所有文件丢失了，从备份中挑选一份rdb去恢复master; 这样才能确保master启动的时候，是有数据的。<ul>
<li>注意：slave node可以自动接管master node，但是也可能sentinal还没有检测到master failure，master node就自动重启了，还是可能导致上面的所有slave node数据清空故障。</li>
</ul>
</li>
</ul>
<h1 id="redis-replication-高可用"><a href="#redis-replication-高可用" class="headerlink" title="redis replication 高可用"></a>redis replication 高可用</h1><ul>
<li>redis高可用架构，叫做故障转移 failover，也可以叫做主备切换。<ul>
<li>一旦master故障，在很短时间内，就会切换到另外一个master上去，可能redis就几分钟或者几秒钟不可用。</li>
</ul>
</li>
<li>当然这是，<strong>redis replication基于哨兵sentinal的高可用性</strong>。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【Redis】生产环境启动方案]]></title>
      <url>/2018/01/31/%E3%80%90Redis%E3%80%91%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%90%AF%E5%8A%A8%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一般的学习，随便用<code>redis-server</code>启动一下redis，做一些实验，这样的话，没什么意义。要把redis作为一个系统的daemon进程去运行的，每次系统启动，redis进程一起启动<br>配置步骤：<br>（1）redis <code>utils</code>目录下，有个<code>redis_init_script</code>脚本<br>（2）将<code>redis_init_script</code>脚本拷贝到linux的<code>/etc/init.d</code>目录中，将<code>redis_init_script</code>重命名为<code>redis_6379</code>，6379是我们希望这个redis实例监听的端口号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp redis_init_script /etc/init.d</div><div class="line">cd /etc/init.d</div><div class="line">mv redis_init_script redis_6379</div></pre></td></tr></table></figure></p>
<p>（3）修改<code>redis_6379</code>脚本的第6行的<code>REDISPORT</code>，设置为相同的端口号（默认就是6379）<br>（4）创建两个目录：<code>/etc/redis</code>（存放redis的配置文件），<code>/var/redis/6379</code>（存放redis的持久化文件）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir /etc/redis</div><div class="line">mkdir -p /var/redis/6379</div></pre></td></tr></table></figure></p>
<p>（5）修改redis配置文件（默认在根目录下，<code>redis.conf</code>），拷贝到<code>/etc/redis</code>目录中，修改名称为<code>6379.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp redis.conf /etc/redis</div><div class="line">mv redis.conf 6379.conf</div></pre></td></tr></table></figure></p>
<p>（6）修改<code>redis.conf</code>中的部分配置为生产环境:</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:center">值</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">daemonize</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">让redis以daemon进程运行</td>
</tr>
<tr>
<td style="text-align:left">pidfile</td>
<td style="text-align:center">/var/run/redis_6379.pid</td>
<td style="text-align:center">设置redis的pid文件位置</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:center">6379(默认值)</td>
<td style="text-align:center">设置redis的监听端口号</td>
</tr>
<tr>
<td style="text-align:left">dir</td>
<td style="text-align:center">/var/redis/6379</td>
<td style="text-align:center">设置持久化文件的存储位置</td>
</tr>
</tbody>
</table>
<p>（7）启动redis，执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /etc/init.d</div><div class="line">chmod 777 redis_6379</div><div class="line">./redis_6379 start</div></pre></td></tr></table></figure></p>
<p>（8）确认redis进程是否启动，<code>ps -ef | grep redis</code><br>（9）让redis跟随系统启动自动启动,在<code>redis_6379</code>脚本中，最上面，加入两行注释:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># chkconfig:   2345 90 10</div><div class="line"># description:  Redis is a persistent key-value database</div></pre></td></tr></table></figure></p>
<p>（10）执行：<code>chkconfig redis_6379 on</code></p>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【技术杂技】Lombok]]></title>
      <url>/2017/11/12/%E3%80%90%E6%8A%80%E6%9C%AF%E6%9D%82%E6%8A%80%E3%80%91lombok/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际开发中，大家都应该会碰到一个场景：定义大量的entity，然后通过Eclipse或者IDEA去生成其属性的构造器、getter、setter、equals、hashcode、toString方法；当要对某个属性进行改变时，都需要重新生成这些方法，那Java中有没有一种方式能够解决这个问题呢？答案是有，就是lombok。</p>
<h1 id="Lombok简介"><a href="#Lombok简介" class="headerlink" title="Lombok简介"></a>Lombok简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lombok是一个可以通过简单的注解形式来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，通过使用对应的注解，可以在编译源码的时候生成对应的方法。</p>
<blockquote>
<p>官方地址：<a href="https://projectlombok.org/" target="_blank" rel="noopener">https://projectlombok.org/</a><br>github地址：<a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener">https://github.com/rzwitserloot/lombok</a></p>
</blockquote>
<h1 id="Lombok安装（IDEA）"><a href="#Lombok安装（IDEA）" class="headerlink" title="Lombok安装（IDEA）"></a>Lombok安装（IDEA）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Settings -&gt; Plugins -&gt; Browse repositories<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="http://s1.wailian.download/2017/11/12/image.png" alt="image.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等安装完，重启一下。因为我常用IDEA，至于Eclipse安装lombok插件，请自行百度一下。</p>
<h1 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h1><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</div><div class="line">    &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h1 id="常用注解介绍"><a href="#常用注解介绍" class="headerlink" title="常用注解介绍"></a>常用注解介绍</h1><h2 id="Getter-Setter-Accessors"><a href="#Getter-Setter-Accessors" class="headerlink" title="Getter Setter Accessors"></a>Getter Setter Accessors</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@Getter @Setter</code>修饰任何字段，让lombok自动生成默认的getter / setter方法，默认生成的方法是public的。如果要修改方法修饰符可以设置AccessLevel的值，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Getter</span>(AccessLevel.PROTECTED)</div></pre></td></tr></table></figure></p>
<p><code>@Accessors</code> 主要用于控制生成的getter和setter,主要参数介绍：</p>
<ul>
<li>fluent boolean值，默认为false。此字段主要为控制生成的getter和setter方法前面是否带get/set</li>
<li>chain boolean值，默认false。如果设置为true，setter返回的是此对象，方便链式调用方法</li>
<li>prefix 设置前缀 例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Accessors</span>(prefix = <span class="string">"abc"</span>) <span class="keyword">private</span> String abcAge ;</div><div class="line"><span class="comment">//当生成get/set方法时，会把此前缀去掉</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="构造器相关"><a href="#构造器相关" class="headerlink" title="构造器相关"></a>构造器相关</h2><ul>
<li><code>@NoArgsConstructor</code> 生成一个无参构造方法。当类中有final字段没有被初始化时，编译器会报错，此时可用<code>@NoArgsConstructor(force = true)</code>，然后就会为没有初始化的final字段设置默认值 0 / false / null。对于具有约束的字段（例如<code>@NonNull</code>字段），不会生成检查或分配，因此请注意，正确初始化这些字段之前，这些约束无效。</li>
<li><p><code>@RequiredArgsConstructor</code> 会生成构造方法（可能带参数也可能不带参数），如果带参数，这参数只能是以final修饰的未经初始化的字段，或者是以<code>@NonNull</code>注解的未经初始化的字段.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequiredArgsConstructor</span>(staticName = <span class="string">"of"</span>)</div><div class="line"><span class="comment">// 会生成一个of()的静态方法，并把构造方法设置为私有的</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>@AllArgsConstructor</code> 生成一个全参数的构造方法</p>
</li>
</ul>
<h2 id="ToString"><a href="#ToString" class="headerlink" title="ToString"></a>ToString</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ToString</code>生成toString()方法，默认情况下，会按顺序 （以逗号分隔）打印你的类名称以及每个字段，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">User(id=<span class="keyword">null</span>, name=<span class="keyword">null</span>, age=<span class="keyword">null</span>)</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样设置不包含哪些字段，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ToString</span>(exclude = <span class="string">"id"</span>) </div><div class="line"><span class="meta">@ToString</span>(exclude = &#123;<span class="string">"id"</span>,<span class="string">"name"</span>&#125;)</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果继承的有父类的话，可以设置callSuper 让其调用父类的toString()方法，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@ToString</span>(callSuper = <span class="keyword">true</span>)</div></pre></td></tr></table></figure></p>
<h2 id="Equals-amp-HashCode"><a href="#Equals-amp-HashCode" class="headerlink" title="Equals&amp;HashCode"></a>Equals&amp;HashCode</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@EqualsAndHashCode</code>，生成hashCode()和equals()方法，默认情况下，它将使用所有非静态，非transient字段。但可以通过在可选的exclude参数中来排除更多字段。或者，通过在parameter参数中命名它们来准确指定希望使用哪些字段。</p>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>@Data</code>包含了<code>@ToString</code>，<code>@EqualsAndHashCode</code>，<code>@Getter</code> / <code>@Setter</code>和<code>@RequiredArgsConstructor</code>的功能</p>
<h2 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h2><p><code>@Synchronized</code>：给方法加上同步锁<br><code>@Wither</code> ：提供了给final字段赋值的一种方法<br><code>@onX</code> ： 在注解里面添加注解的方式<br><code>@Builder</code>：为你的类生成复杂的构建器API。<br><code>@Delegate</code>：这个注解也是相当的牛逼，它会该类生成一些列的方法，这些方法都来自与List接口<br><code>@Log4j</code> ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其他注解，查询官方文档。</p>
<h1 id="Lombok问题"><a href="#Lombok问题" class="headerlink" title="Lombok问题"></a>Lombok问题</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lombok 很强大，是生产力神器，语法设计合理易用，当然也很邪恶。从原理上来说，Lombok的魔法就在于其修改了AST(抽象语法树)，分析和生成class阶段使用了修改后的AST，也就最终改变了生成的字节码文件。所以说，它甚至在某种程度上重新定义了 Java 本身的语法（写法），而这种“非官方”的重定义是不是会带来一系列问题也未可知，只能实践求证。以下是我开发中碰到的一些问题：</p>
<ul>
<li>无法支持多种参数构造器的重载</li>
<li>大大降低了源代码文件的可读性和完整性，降低了阅读源代码的舒适度</li>
<li>代码易手时带来的注解冲突、Java新手的掌握成本等等一系列问题</li>
<li>奇淫巧技，使用会有争议</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 技术杂技 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 技术杂技 </tag>
            
            <tag> tool </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[【设计模式】单例模式]]></title>
      <url>/2017/10/12/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在GoF的23种设计模式中，单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。这里主要介绍5种写法。</p>
<h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下写法，是基于classloader机制，避免了多线程的同步问题，但在加载时没有达到lazy loading的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    	<span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="懒汉式-非线程安全"><a href="#懒汉式-非线程安全" class="headerlink" title="懒汉式-非线程安全"></a>懒汉式-非线程安全</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下写法，lazy loading很明显，但是致命的是在多线程不能正常工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    	&#125;  </div><div class="line">    	<span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式-线程安全"></a>懒汉式-线程安全</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种写法能在多线程中很好的工作，而且具备lazy loading，但同步方法效率很低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">    	<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">            instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    	&#125;  </div><div class="line">    	<span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="double-check"><a href="#double-check" class="headerlink" title="double check"></a>double check</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种写法是比较推崇的一种写法。加锁双重检查对效率也有一定影响，不过影响不大。流程分析：为了防止new Singleton被执行多次，因此在new操作之前加Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubbleSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DubbleSingleton ds;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DubbleSingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DubbleSingleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</div><div class="line">    	<span class="keyword">if</span>(ds == <span class="keyword">null</span>)&#123;</div><div class="line">    	    <span class="keyword">synchronized</span> (DubbleSingleton.class) &#123;</div><div class="line">                <span class="keyword">if</span>(ds == <span class="keyword">null</span>)&#123;</div><div class="line">                    ds = <span class="keyword">new</span> DubbleSingleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">    	&#125;</div><div class="line">    	<span class="keyword">return</span> ds;</div><div class="line">    &#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方式:InnerSingleton类被装载了，Singletion不一定被初始化。因为Singletion类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类。有效的实现了 lazy loading，同时也避免加锁。本质上利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletion</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singletion single = <span class="keyword">new</span> Singletion();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singletion <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> Singletion.single;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终问题：静态内部类的实现方式虽好，但是存在着单例模式共同的问题：无法防止利用反射来重复构建对象。</p>
<h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了enum语法糖，JVM会组织反射获取枚举类的私有构造方法。使用枚举类实现的单例模式不仅能够防止反射构造对象，而且可以保证线程安全。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种方式也有唯一的缺点，就是它并非使用懒加载，其单例对象实在枚举类被加载的时候进行初始化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SingletonEnum &#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><p><img src="http://s1.wailian.download/2017/12/12/image.png" alt="image.png"></p>
<p><strong>注意注意</strong>：</p>
<ul>
<li>volatile关键字不但可以防止指令重排，也可以保证线程访问的变量值是主内存中的最新值。有关volatile的详细原理，我在以后的漫画中会专门讲解。</li>
<li>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。</li>
<li>对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 设计模式 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
